<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Luna Character</title>
  <!-- Live2D Cubism SDK (‡πÉ‡∏ä‡πâ CDN ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö) -->
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@7/dist/pixi.min.js"></script>
  <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
  <!-- Note: pixi-live2d-display@0.4.0 ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö model3.json (Cubism 4.0) -->
  <!-- ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ Live2D Cubism SDK ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡πÅ‡∏ó‡∏ô -->
  <script type="module">
    // Try to load as ES module first
    try {
      const { Live2DModel } = await import('https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/index.min.js');
      window.Live2DModel = Live2DModel;
      console.log('[Live2D] ‚úÖ Loaded Live2DModel via ES module');
    } catch (e) {
      console.warn('[Live2D] ES module import failed, trying script tag...', e);
      // Fallback to script tag
      (function() {
        const cdnUrls = [
          'https://unpkg.com/pixi-live2d-display@0.4.0/dist/index.min.js',
          'https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/index.min.js',
        ];
        const localPath = '/public/libs/pixi-live2d-display.min.js';
        
        function loadScript(src, index) {
          const script = document.createElement('script');
          script.src = src;
          script.onload = function() {
            console.log('[Live2D] ‚úÖ Successfully loaded from:', src);
            // Wait a bit for library to initialize
            setTimeout(() => {
              console.log('[Live2D] Library loaded, checking availability...');
              if (typeof PIXI !== 'undefined' && PIXI.live2d) {
                console.log('[Live2D] PIXI.live2d available:', Object.keys(PIXI.live2d));
                console.log('[Live2D] PIXI.live2d.config:', PIXI.live2d.config);
              }
              // Check for Live2DModel in various places
              if (typeof window !== 'undefined') {
                const windowKeys = Object.keys(window).filter(k => 
                  k.includes('Live2D') || k.includes('live2d') || k.includes('Model')
                );
                console.log('[Live2D] Window keys with Live2D/Model:', windowKeys);
              }
            }, 500);
          };
          script.onerror = function() {
            if (index < cdnUrls.length - 1) {
              loadScript(cdnUrls[index + 1], index + 1);
            } else if (src !== localPath) {
              loadScript(localPath, -1);
            } else {
              console.error('[Live2D] ‚ùå All sources failed.');
            }
          };
          document.head.appendChild(script);
        }
        loadScript(cdnUrls[0], 0);
      })();
    }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: transparent;
      font-family: Arial, sans-serif;
    }

    #character-container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #character-canvas {
      width: 100%;
      height: 100%;
      image-rendering: crisp-edges;
      image-rendering: -webkit-optimize-contrast;
    }

    /* Debug info (‡∏ã‡πà‡∏≠‡∏ô‡πÉ‡∏ô production) */
    #debug-info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      font-size: 12px;
      border-radius: 5px;
      display: none; /* ‡∏ã‡πà‡∏≠‡∏ô‡πÑ‡∏ß‡πâ ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡∏î‡πâ‡∏ß‡∏¢ ?debug=true */
    }

    #debug-info.active {
      display: block;
    }
  </style>
</head>
<body>
  <div id="character-container">
    <canvas id="character-canvas"></canvas>
    <div id="debug-info">
      <div>Status: <span id="status">Connecting...</span></div>
      <div>Emotion: <span id="emotion">-</span></div>
      <div>Mouth: <span id="mouth">0</span></div>
      <div>Eye: <span id="eye">1</span></div>
      <div>Energy: <span id="energy">1.0</span></div>
    </div>
  </div>

  <script>
    // ============================================
    // Luna Character Controller
    // ============================================
    
    const canvas = document.getElementById('character-canvas');
    const ctx = canvas.getContext('2d');
    const debugInfo = document.getElementById('debug-info');
    
    // Canvas setup
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Check for debug mode
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('debug') === 'true') {
      debugInfo.classList.add('active');
    }
    
    // ============================================
    // Character State
    // ============================================
    const state = {
      // Physical state
      mouthOpen: 0,        // 0-1
      eyeOpen: 1,          // 0-1 (0 = closed, 1 = open)
      eyeBlink: false,     // true when blinking
      breathing: 0,        // 0-1 (breathing cycle)
      faceAngleX: 0,       // -15 to 15 degrees
      faceAngleY: 0,       // -15 to 15 degrees
      faceAngleZ: 0,       // -15 to 15 degrees
      
      // Emotional state
      emotion: 'neutral',  // neutral, happy, sad, angry, sleepy, hype, soft
      emotionIntensity: 0.5, // 0-1
      
      // Energy state
      energy: 1.0,         // 0-1
      
      // Animation state
      idleAnimation: null,
      microMovement: null,
      
      // Timing
      lastBlink: Date.now(),
      lastMicroMove: Date.now(),
      lastEyeMove: Date.now(),
    };
    
    // ============================================
    // Live2D Model Loading
    // ============================================
    let live2dModel = null;
    let live2dApp = null;
    let live2dStage = null;
    let useLive2D = false;
    
    // Get model name from URL parameter (urlParams already declared above)
    const modelName = urlParams.get('model') || null; // null = ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ Live2D, ‡πÉ‡∏ä‡πâ placeholder
    
    // Initialize Live2D (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ model parameter)
    async function initLive2D() {
      if (!modelName) {
        console.log('[Character] No model specified, using placeholder');
        return false;
      }
      
      try {
        // Check if Live2D libraries are loaded
        if (typeof PIXI === 'undefined') {
          console.warn('[Live2D] PIXI.js not loaded, using placeholder');
          return false;
        }
        
        // Wait for Live2D core to load
        if (typeof Live2DCubismCore === 'undefined') {
          console.warn('[Live2D] Live2D Core not loaded, using placeholder');
          return false;
        }
        
        // Wait for pixi-live2d-display to load
        // Check multiple ways the library might be exposed
        console.log('[Live2D] Checking library availability...');
        console.log('[Live2D] PIXI:', typeof PIXI !== 'undefined' ? '‚úÖ' : '‚ùå');
        console.log('[Live2D] PIXI.live2d:', typeof PIXI !== 'undefined' && typeof PIXI.live2d !== 'undefined' ? '‚úÖ' : '‚ùå');
        
        // Check for Live2DModel in different possible locations
        let Live2DModelClass = null;
        
        // Method 1: PIXI.live2d.Live2DModel
        if (typeof PIXI !== 'undefined' && PIXI.live2d && PIXI.live2d.Live2DModel) {
          Live2DModelClass = PIXI.live2d.Live2DModel;
          console.log('[Live2D] ‚úÖ Found Live2DModel at PIXI.live2d.Live2DModel');
        }
        // Method 2: window.Live2DModel
        else if (typeof window !== 'undefined' && window.Live2DModel) {
          Live2DModelClass = window.Live2DModel;
          console.log('[Live2D] ‚úÖ Found Live2DModel at window.Live2DModel');
        }
        // Method 3: PIXI.live2d.Live2DSprite (alternative)
        else if (typeof PIXI !== 'undefined' && PIXI.live2d && PIXI.live2d.Live2DSprite) {
          Live2DModelClass = PIXI.live2d.Live2DSprite;
          console.log('[Live2D] ‚úÖ Found Live2DSprite at PIXI.live2d.Live2DSprite');
        }
        // Method 4: Check all PIXI.live2d properties
        else if (typeof PIXI !== 'undefined' && PIXI.live2d) {
          console.log('[Live2D] Checking all PIXI.live2d properties...');
          const live2dKeys = Object.keys(PIXI.live2d);
          console.log('[Live2D] PIXI.live2d keys:', live2dKeys);
          console.log('[Live2D] PIXI.live2d.config:', PIXI.live2d.config);
          
          // Check if config has Model class
          if (PIXI.live2d.config && PIXI.live2d.config.Model) {
            Live2DModelClass = PIXI.live2d.config.Model;
            console.log('[Live2D] ‚úÖ Found Model at PIXI.live2d.config.Model');
          }
          
          // Look for any class that has a 'from' method
          if (!Live2DModelClass) {
            for (const key of live2dKeys) {
              const obj = PIXI.live2d[key];
              if (obj && typeof obj === 'function' && typeof obj.from === 'function') {
                Live2DModelClass = obj;
                console.log(`[Live2D] ‚úÖ Found model class at PIXI.live2d.${key}`);
                break;
              }
            }
          }
          
          // Check all properties recursively
          if (!Live2DModelClass) {
            console.log('[Live2D] Checking all properties recursively...');
            for (const key of live2dKeys) {
              const obj = PIXI.live2d[key];
              if (obj && typeof obj === 'object') {
                const subKeys = Object.keys(obj);
                console.log(`[Live2D] PIXI.live2d.${key} has:`, subKeys);
                for (const subKey of subKeys) {
                  if (obj[subKey] && typeof obj[subKey] === 'function' && typeof obj[subKey].from === 'function') {
                    Live2DModelClass = obj[subKey];
                    console.log(`[Live2D] ‚úÖ Found model class at PIXI.live2d.${key}.${subKey}`);
                    break;
                  }
                }
              }
              if (Live2DModelClass) break;
            }
          }
        }
        
        // Method 5: Check window for exported classes
        if (!Live2DModelClass && typeof window !== 'undefined') {
          console.log('[Live2D] Checking window for Live2D classes...');
          const windowKeys = Object.keys(window).filter(k => 
            k.includes('Live2D') || k.includes('live2d') || k.includes('Model')
          );
          console.log('[Live2D] Window keys with Live2D/Model:', windowKeys);
          for (const key of windowKeys) {
            const obj = window[key];
            if (obj && typeof obj === 'function' && typeof obj.from === 'function') {
              Live2DModelClass = obj;
              console.log(`[Live2D] ‚úÖ Found model class at window.${key}`);
              break;
            }
          }
        }
        
        if (!Live2DModelClass) {
          console.warn('[Live2D] ‚ùå Live2DModel class not found, using placeholder');
          console.warn('[Live2D] Available PIXI.live2d properties:', typeof PIXI !== 'undefined' && PIXI.live2d ? Object.keys(PIXI.live2d) : 'N/A');
          console.warn('[Live2D] PIXI.live2d.config:', typeof PIXI !== 'undefined' && PIXI.live2d ? PIXI.live2d.config : 'N/A');
          console.warn('[Live2D] window properties:', typeof window !== 'undefined' ? Object.keys(window).filter(k => k.includes('Live2D') || k.includes('live2d') || k.includes('Model')) : 'N/A');
          
          // Try to use Live2D Cubism SDK directly
          console.log('[Live2D] üí° Attempting to use Live2D Cubism SDK directly...');
          if (typeof Live2DCubismCore !== 'undefined') {
            console.log('[Live2D] Live2DCubismCore available:', Object.keys(Live2DCubismCore || {}));
          }
          
          return false;
        }
        
        // Verify that Live2DModelClass has a 'from' method
        if (typeof Live2DModelClass.from !== 'function') {
          console.warn('[Live2D] ‚ùå Live2DModelClass.from is not a function');
          console.warn('[Live2D] Live2DModelClass:', Live2DModelClass);
          console.warn('[Live2D] Live2DModelClass methods:', Object.getOwnPropertyNames(Live2DModelClass));
          return false;
        }
        
        console.log('[Live2D] ‚úÖ pixi-live2d-display is available');
        console.log('[Live2D] Live2DModelClass:', Live2DModelClass.name || 'Anonymous');
        console.log('[Live2D] Live2DModelClass.from:', typeof Live2DModelClass.from);
        
        // Create PIXI application (use same canvas)
        live2dApp = new PIXI.Application({
          view: canvas,
          autoStart: true,
          transparent: true,
          backgroundAlpha: 0,
          resizeTo: canvas,
          antialias: true,
        });
        
        // Clear canvas context when switching to Live2D
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        live2dStage = live2dApp.stage;
        
        // Get Live2DModel class (should be set above)
        if (!Live2DModelClass) {
          throw new Error('Live2DModel class not found - cannot load model');
        }
        
        // Model path
        // Try different model file name patterns
        const modelFileNames = [
          `${modelName}.model3.json`,           // shuangsheng.model3.json
          `${modelName.toLowerCase()}.model3.json`, // shuangsheng.model3.json (same)
          `model.model3.json`                   // model.model3.json (fallback)
        ];
        
        let MODEL_PATH = null;
        let model = null;
        
        console.log('[Live2D] Model name:', modelName);
        console.log('[Live2D] Will try file names:', modelFileNames);
        
        // Try each filename pattern
        for (const fileName of modelFileNames) {
          // Try both /models/ and /public/models/ paths
          const testPaths = [
            `/models/${modelName}/${fileName}`,
            `/public/models/${modelName}/${fileName}`
          ];
          
          for (const testPath of testPaths) {
            console.log('[Live2D] üîç Trying model path:', testPath);
            try {
              
              console.log('[Live2D] Using Live2DModel.from() to load:', testPath);
              console.log('[Live2D] Live2DModelClass type:', typeof Live2DModelClass);
              console.log('[Live2D] Live2DModelClass.from type:', typeof Live2DModelClass.from);
              
              // Try to load the model
              model = await Live2DModelClass.from(testPath);
              MODEL_PATH = testPath;
              console.log('[Live2D] ‚úÖ Successfully loaded model from:', MODEL_PATH);
              break;
            } catch (e) {
              console.error('[Live2D] ‚ùå Failed to load from:', testPath);
              console.error('[Live2D] Error type:', e.constructor.name);
              console.error('[Live2D] Error message:', e.message);
              if (e.stack) {
                console.error('[Live2D] Error stack:', e.stack);
              }
              // Check if it's a network error (404, CORS, etc.)
              if (e.message && (e.message.includes('404') || e.message.includes('Failed to fetch') || e.message.includes('CORS'))) {
                console.error('[Live2D] ‚ö†Ô∏è This looks like a network/CORS issue. Check server configuration.');
              }
              // Continue to next path
            }
          }
          
          if (model) break; // Exit outer loop if model loaded
        }
        
        if (!model) {
          throw new Error(`Could not load model from any path. Tried: ${modelFileNames.join(', ')}`);
        }
        
        // Center model
        model.x = canvas.width / 2;
        model.y = canvas.height / 2;
        const baseScale = Math.min(canvas.width, canvas.height) / 1000;
        model.scale.set(baseScale);
        
        live2dStage.addChild(model);
        live2dModel = model;
        useLive2D = true;
        
        console.log('[Live2D] Model loaded successfully!');
        return true;
      } catch (error) {
        console.error('[Live2D] Failed to load model:', error);
        console.log('[Live2D] Falling back to placeholder character');
        useLive2D = false;
        return false;
      }
    }
    
    // ============================================
    // Character Rendering
    // ============================================
    function drawCharacter() {
      // If Live2D model is loaded, use it
      if (live2dModel && live2dApp && useLive2D) {
        updateLive2DModel();
        // Live2D renders automatically via PIXI
        updateDebugInfo();
        return;
      }
      
      // Otherwise, use placeholder
      // Clear entire canvas first
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const scale = Math.min(canvas.width, canvas.height) / 800;
      
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.scale(scale, scale);
      
      // Apply face rotation
      ctx.rotate((state.faceAngleZ * Math.PI) / 180);
      
      // Draw placeholder character
      drawPlaceholderCharacter();
      
      ctx.restore();
      
      // Update debug info
      updateDebugInfo();
    }
    
    // Update Live2D model parameters
    function updateLive2DModel() {
      if (!live2dModel || !useLive2D) return;
      
      try {
        const coreModel = live2dModel.internalModel.coreModel;
        const currentTime = Date.now() / 1000;
        
        // Update mouth (ParamMouthOpen or MouthOpen)
        const mouthParamNames = ['ParamMouthOpen', 'MouthOpen', 'PARAM_MOUTH_OPEN_Y'];
        for (const paramName of mouthParamNames) {
          const paramIndex = coreModel.getParameterIndexById(paramName);
          if (paramIndex !== -1) {
            coreModel.setParameterValueByIndex(paramIndex, state.mouthOpen);
            break;
          }
        }
        
        // Update eyes (ParamEyeLOpen, ParamEyeROpen)
        const eyeLParamNames = ['ParamEyeLOpen', 'ParamEyeL', 'PARAM_EYE_L_OPEN'];
        const eyeRParamNames = ['ParamEyeROpen', 'ParamEyeR', 'PARAM_EYE_R_OPEN'];
        
        for (const paramName of eyeLParamNames) {
          const paramIndex = coreModel.getParameterIndexById(paramName);
          if (paramIndex !== -1) {
            coreModel.setParameterValueByIndex(paramIndex, state.eyeOpen);
            break;
          }
        }
        
        for (const paramName of eyeRParamNames) {
          const paramIndex = coreModel.getParameterIndexById(paramName);
          if (paramIndex !== -1) {
            coreModel.setParameterValueByIndex(paramIndex, state.eyeOpen);
            break;
          }
        }
        
        // Update face angle (ParamAngleX, ParamAngleY, ParamAngleZ)
        const angleXParamNames = ['ParamAngleX', 'ParamAngleX', 'PARAM_ANGLE_X'];
        const angleYParamNames = ['ParamAngleY', 'ParamAngleY', 'PARAM_ANGLE_Y'];
        const angleZParamNames = ['ParamAngleZ', 'ParamAngleZ', 'PARAM_ANGLE_Z'];
        
        for (const paramName of angleXParamNames) {
          const paramIndex = coreModel.getParameterIndexById(paramName);
          if (paramIndex !== -1) {
            coreModel.setParameterValueByIndex(paramIndex, state.faceAngleX);
            break;
          }
        }
        
        for (const paramName of angleYParamNames) {
          const paramIndex = coreModel.getParameterIndexById(paramName);
          if (paramIndex !== -1) {
            coreModel.setParameterValueByIndex(paramIndex, state.faceAngleY);
            break;
          }
        }
        
        for (const paramName of angleZParamNames) {
          const paramIndex = coreModel.getParameterIndexById(paramName);
          if (paramIndex !== -1) {
            coreModel.setParameterValueByIndex(paramIndex, state.faceAngleZ);
            break;
          }
        }
        
        // Update breathing (ParamBreath)
        const breathParamNames = ['ParamBreath', 'Breath', 'PARAM_BREATH'];
        for (const paramName of breathParamNames) {
          const paramIndex = coreModel.getParameterIndexById(paramName);
          if (paramIndex !== -1) {
            const breathValue = Math.sin(state.breathing * Math.PI * 2) * 0.5 + 0.5;
            coreModel.setParameterValueByIndex(paramIndex, breathValue);
            break;
          }
        }
        
        // Update model position/scale based on breathing
        const breathScale = 1 + (Math.sin(state.breathing * Math.PI * 2) * 0.02);
        const baseScale = Math.min(canvas.width, canvas.height) / 1000;
        live2dModel.scale.set(baseScale * breathScale);
        
        // Update model position
        live2dModel.x = canvas.width / 2;
        live2dModel.y = canvas.height / 2;
        
        // Update model (important for Live2D animation)
        live2dModel.internalModel.update(currentTime);
      } catch (error) {
        console.warn('[Live2D] Error updating model:', error);
      }
    }
    
    function drawPlaceholderCharacter() {
      // Clear and set background (transparent for OBS)
      ctx.clearRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2);
      
      // Canvas placeholder (fallback only - should use Live2D model)
      // Head
      ctx.fillStyle = '#FFE4E1';
      ctx.beginPath();
      ctx.arc(0, -100, 80, 0, Math.PI * 2);
      ctx.fill();
      
      // Bunny ears
      ctx.fillStyle = '#FFB6C1';
      ctx.beginPath();
      ctx.ellipse(-30, -180, 20, 50, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(30, -180, 20, 50, 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes
      const eyeY = -110;
      const eyeSpacing = 30;
      const eyeSize = 15;
      
      // Left eye
      ctx.fillStyle = '#FF6B6B';
      ctx.beginPath();
      ctx.ellipse(-eyeSpacing, eyeY, eyeSize * state.eyeOpen, eyeSize * state.eyeOpen, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Right eye
      ctx.beginPath();
      ctx.ellipse(eyeSpacing, eyeY, eyeSize * state.eyeOpen, eyeSize * state.eyeOpen, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Mouth
      ctx.fillStyle = '#FF1493';
      const mouthHeight = 10 + (state.mouthOpen * 15);
      ctx.beginPath();
      ctx.ellipse(0, -70, 20, mouthHeight, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Body (simple)
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(-40, -20, 80, 120);
      
      // Breathing effect (subtle scale)
      const breathScale = 1 + (Math.sin(state.breathing * Math.PI * 2) * 0.02);
      ctx.scale(breathScale, breathScale);
    }
    
    function updateDebugInfo() {
      document.getElementById('status').textContent = 'Connected';
      document.getElementById('emotion').textContent = state.emotion;
      document.getElementById('mouth').textContent = state.mouthOpen.toFixed(2);
      document.getElementById('eye').textContent = state.eyeOpen.toFixed(2);
      document.getElementById('energy').textContent = state.energy.toFixed(2);
    }
    
    // ============================================
    // Animation Loops
    // ============================================
    
    // Breathing animation
    function updateBreathing() {
      const breathingSpeed = 0.001; // Slower breathing when tired
      state.breathing += breathingSpeed * (0.5 + state.energy * 0.5);
      if (state.breathing > 1) state.breathing -= 1;
    }
    
    // Blink animation
    function updateBlink() {
      const now = Date.now();
      const timeSinceLastBlink = now - state.lastBlink;
      
      // Random blink interval (3-7 seconds)
      const blinkInterval = 3000 + Math.random() * 4000;
      
      if (timeSinceLastBlink > blinkInterval) {
        // Start blink
        state.eyeBlink = true;
        state.eyeOpen = 0;
        state.lastBlink = now;
        
        // End blink after 200ms
        setTimeout(() => {
          state.eyeBlink = false;
          state.eyeOpen = 1;
        }, 200);
      }
    }
    
    // Micro-movements (small random movements)
    function updateMicroMovements() {
      const now = Date.now();
      const timeSinceLastMove = now - state.lastMicroMove;
      
      // Random micro-movement interval (5-15 seconds)
      if (timeSinceLastMove > 5000 + Math.random() * 10000) {
        // Small random face angle change
        state.faceAngleX = (Math.random() - 0.5) * 10;
        state.faceAngleY = (Math.random() - 0.5) * 5;
        state.faceAngleZ = (Math.random() - 0.5) * 5;
        
        // Reset after 2 seconds
        setTimeout(() => {
          state.faceAngleX = 0;
          state.faceAngleY = 0;
          state.faceAngleZ = 0;
        }, 2000);
        
        state.lastMicroMove = now;
      }
    }
    
    // Eye movement (look around)
    function updateEyeMovement() {
      const now = Date.now();
      const timeSinceLastEyeMove = now - state.lastEyeMove;
      
      // Random eye movement interval (3-8 seconds)
      if (timeSinceLastEyeMove > 3000 + Math.random() * 5000) {
        // Small random eye direction
        state.faceAngleX = (Math.random() - 0.5) * 15;
        state.faceAngleY = (Math.random() - 0.5) * 10;
        
        // Reset after 1.5 seconds
        setTimeout(() => {
          state.faceAngleX = 0;
          state.faceAngleY = 0;
        }, 1500);
        
        state.lastEyeMove = now;
      }
    }
    
    // Main animation loop
    let animationRunning = false;
    
    function animate() {
      if (!animationRunning) {
        animationRunning = true;
        console.log('[Character] Animation loop is running');
      }
      
      updateBreathing();
      updateBlink();
      updateMicroMovements();
      updateEyeMovement();
      
      drawCharacter();
      requestAnimationFrame(animate);
    }
    
    // ============================================
    // WebSocket Connection
    // ============================================
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = window.location.hostname || 'localhost';
    const wsPort = window.location.port || '8787';
    const ws = new WebSocket(`${wsProtocol}//${wsHost}:${wsPort}`);
    
    ws.onopen = () => {
      console.log('[Luna Character] Connected to server');
      document.getElementById('status').textContent = 'Connected';
    };
    
    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        handleMessage(data);
      } catch (e) {
        console.error('[Luna Character] Parse error:', e);
      }
    };
    
    ws.onerror = (error) => {
      console.error('[Luna Character] WebSocket error:', error);
      document.getElementById('status').textContent = 'Error';
    };
    
    ws.onclose = () => {
      console.log('[Luna Character] Disconnected');
      document.getElementById('status').textContent = 'Disconnected';
      // Try to reconnect after 3 seconds
      setTimeout(() => {
        location.reload();
      }, 3000);
    };
    
    // ============================================
    // Message Handler
    // ============================================
    function handleMessage(data) {
      switch (data.type) {
        case 'luna_message':
          // When Luna speaks, animate mouth
          if (data.ttsUrl) {
            animateMouthForSpeech(data.text);
          }
          break;
        
        case 'luna_reading_comment':
          // When reading comment, animate mouth
          animateMouthForSpeech(data.text);
          break;
        
        case 'audio_react':
          // Audio level for mouth movement (improved sync)
          if (data.level > 0.05) {
            // Smooth mouth opening based on audio level
            const targetMouthOpen = Math.min(1, data.level * 2.0);
            // Smooth transition (avoid sudden jumps)
            state.mouthOpen = state.mouthOpen * 0.7 + targetMouthOpen * 0.3;
          } else {
            // Gradually close mouth when no audio
            state.mouthOpen = state.mouthOpen * 0.9;
          }
          break;
        
        case 'emotion_update':
          // Update emotion
          if (data.emotion) {
            state.emotion = data.emotion;
            state.emotionIntensity = data.intensity || 0.5;
            applyEmotionAnimation(data.emotion);
          }
          break;
        
        case 'energy_update':
          // Update energy level
          if (typeof data.energy === 'number') {
            state.energy = Math.max(0, Math.min(1, data.energy));
          }
          break;
        
        case 'face_angle':
          // Direct face angle control (smooth transition)
          if (data.x !== undefined) {
            state.faceAngleX = data.x;
          }
          if (data.y !== undefined) {
            state.faceAngleY = data.y;
          }
          if (data.z !== undefined) {
            state.faceAngleZ = data.z;
          }
          break;
        
        case 'character_state':
          // Comprehensive character state update
          if (data.mouthOpen !== undefined) state.mouthOpen = data.mouthOpen;
          if (data.eyeOpen !== undefined) state.eyeOpen = data.eyeOpen;
          if (data.faceAngleX !== undefined) state.faceAngleX = data.faceAngleX;
          if (data.faceAngleY !== undefined) state.faceAngleY = data.faceAngleY;
          if (data.faceAngleZ !== undefined) state.faceAngleZ = data.faceAngleZ;
          if (data.emotion !== undefined) {
            state.emotion = data.emotion;
            applyEmotionAnimation(data.emotion);
          }
          break;
        
        case 'blink':
          // Force blink
          triggerBlink();
          break;
        
        case 'micro_movement':
          // Trigger micro movement
          triggerMicroMovement(data.type);
          break;
      }
    }
    
    // ============================================
    // Animation Functions
    // ============================================
    
    function animateMouthForSpeech(text) {
      const words = text.split(/\s+/).length;
      const duration = Math.max(500, words * 100); // Estimate duration
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress < 1) {
          // Animate mouth opening/closing
          const cycle = Math.sin(progress * Math.PI * 8); // 8 cycles
          state.mouthOpen = Math.max(0, Math.min(1, cycle * 0.7 + 0.3));
          requestAnimationFrame(animate);
        } else {
          // Close mouth after speech
          state.mouthOpen = 0;
        }
      }
      
      animate();
    }
    
    // Current expression state
    let currentExpression = null;
    let expressionTimeout = null;
    
    function applyEmotionAnimation(emotion) {
      // Clear previous expression timeout
      if (expressionTimeout) {
        clearTimeout(expressionTimeout);
        expressionTimeout = null;
      }
      
      // Apply expression to Live2D model
      if (live2dModel && useLive2D) {
        applyLive2DExpression(emotion);
      }
      
      // Apply visual state changes
      switch (emotion) {
        case 'happy':
        case 'hype':
          // More energetic breathing
          state.eyeOpen = 1.1;
          break;
        case 'sad':
          // Slower breathing, slight head down
          state.faceAngleY = 5;
          state.eyeOpen = 0.8;
          setTimeout(() => { state.faceAngleY = 0; }, 2000);
          break;
        case 'sleepy':
          // Slower breathing, eyes half closed
          state.eyeOpen = 0.5;
          break;
        case 'angry':
          // Tense, eyes wide
          state.eyeOpen = 1.2;
          break;
        default:
          state.eyeOpen = 1;
      }
    }
    
    // Apply Live2D expression based on emotion
    function applyLive2DExpression(emotion) {
      if (!live2dModel || !useLive2D) return;
      
      try {
        // Map emotion to expression file name (based on shuangsheng model)
        const expressionMap = {
          'happy': 'aixin',      // Áà±ÂøÉ (love/heart)
          'hype': 'jiyan',       // ÊøÄÁáÉ (excited)
          'sad': 'yanlei',       // ÁúºÊ≥™ (tears)
          'sleepy': 'yun',       // Êôï (dizzy/sleepy)
          'angry': 'heilian',    // ÈªëËÑ∏ (black face/angry)
          'soft': 'baowawa',     // Êä±Â®ÉÂ®É (hugging)
          'neutral': null        // Clear expression
        };
        
        const expressionName = expressionMap[emotion];
        
        if (expressionName) {
          // Try to load expression
          const expressionPath = `/models/${modelName}/${expressionName}.exp3.json`;
          console.log('[Live2D] Applying expression:', expressionName, 'from', expressionPath);
          
          // Note: pixi-live2d-display may have expression methods
          // If not available, we'll use parameter-based approach
          if (live2dModel.internalModel && live2dModel.internalModel.coreModel) {
            // Try to set expression via core model
            // This is a simplified approach - full expression loading may require additional setup
            console.log('[Live2D] Expression system ready (may require additional setup)');
          }
        } else if (emotion === 'neutral') {
          // Clear expression
          console.log('[Live2D] Clearing expression');
        }
        
        currentExpression = emotion;
      } catch (error) {
        console.warn('[Live2D] Error applying expression:', error);
      }
    }
    
    function triggerBlink() {
      if (state.eyeBlink) return; // Already blinking
      
      state.eyeBlink = true;
      state.eyeOpen = 0;
      
      setTimeout(() => {
        state.eyeBlink = false;
        state.eyeOpen = 1;
      }, 200);
    }
    
    function triggerMicroMovement(type) {
      switch (type) {
        case 'ear_twitch':
          // Twitch ears (if you have ear parameters)
          break;
        case 'body_shift':
          // Shift body position
          state.faceAngleX = (Math.random() - 0.5) * 10;
          setTimeout(() => { state.faceAngleX = 0; }, 1000);
          break;
        case 'head_tilt':
          // Tilt head
          state.faceAngleZ = (Math.random() - 0.5) * 15;
          setTimeout(() => { state.faceAngleZ = 0; }, 1500);
          break;
      }
    }
    
    // ============================================
    // Start Application
    // ============================================
    // Start animation loop immediately (don't wait for libraries)
    window.addEventListener('load', () => {
      console.log('[Character] Starting character viewer...');
      console.log('[Character] Canvas size:', canvas.width, 'x', canvas.height);
      console.log('[Character] Canvas context:', ctx ? 'OK' : 'FAILED');
      
      // Draw initial placeholder to verify canvas works
      ctx.fillStyle = '#FFE4E1';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#FF6B6B';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Loading character...', canvas.width / 2, canvas.height / 2);
      
      // Start animation loop immediately (will use placeholder if Live2D not loaded)
      console.log('[Character] Starting animation loop...');
      animate();
      console.log('[Character] Animation loop started!');
      
      // Try to load Live2D in background (non-blocking)
      (async () => {
        console.log('[Live2D] Starting Live2D loading process...');
        
        // Wait a bit before checking libraries (give library time to load)
        console.log('[Live2D] Waiting 1 second for libraries to initialize...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Wait for libraries to load with retry
        let retries = 0;
        const maxRetries = 10;
        
        console.log('[Live2D] Checking if libraries are loaded...');
        
        while (retries < maxRetries) {
          // Check if all libraries are loaded
          const pixiLoaded = typeof PIXI !== 'undefined';
          const coreLoaded = typeof Live2DCubismCore !== 'undefined';
          const live2dLoaded = typeof PIXI !== 'undefined' && typeof PIXI.live2d !== 'undefined';
          const live2dModelAvailable = typeof PIXI !== 'undefined' && 
                                       typeof PIXI.live2d !== 'undefined' && 
                                       typeof PIXI.live2d.Live2DModel !== 'undefined';
          
          console.log(`[Live2D] Check ${retries + 1}/${maxRetries}: PIXI=${pixiLoaded}, Core=${coreLoaded}, Live2D=${live2dLoaded}, Live2DModel=${live2dModelAvailable}`);
          
          if (pixiLoaded && coreLoaded && live2dLoaded && live2dModelAvailable) {
            console.log('[Live2D] ‚úÖ All libraries loaded successfully!');
            break;
          }
          
          // Already checked above
          
          await new Promise(resolve => setTimeout(resolve, 500));
          retries++;
        }
        
        if (retries >= maxRetries) {
          const pixiLoaded = typeof PIXI !== 'undefined';
          const coreLoaded = typeof Live2DCubismCore !== 'undefined';
          const live2dLoaded = typeof PIXI !== 'undefined' && typeof PIXI.live2d !== 'undefined';
          
          console.warn('[Live2D] ‚ö†Ô∏è Libraries failed to load after retries');
          console.warn(`[Live2D] Final status: PIXI=${pixiLoaded}, Core=${coreLoaded}, Live2D=${live2dLoaded}`);
          
          // Even if Live2DModel not found, try to load model anyway (might work differently)
          console.log('[Live2D] Attempting to load model anyway (may use alternative method)...');
          const loaded = await initLive2D();
          if (loaded) {
            console.log('[Live2D] ‚úÖ Successfully loaded Live2D model - switching from placeholder');
          } else {
            console.log('[Live2D] Using placeholder character (this is OK!)');
          }
          return;
        }
        
        // Try to load Live2D model
        console.log('[Live2D] Attempting to load Live2D model...');
        const loaded = await initLive2D();
        if (loaded) {
          console.log('[Live2D] ‚úÖ Successfully loaded Live2D model - switching from placeholder');
        } else {
          console.warn('[Live2D] ‚ùå Failed to load model - continuing with placeholder character');
          console.warn('[Live2D] üí° Tip: Check Network tab to see if model files are being requested');
          console.warn('[Live2D] üí° Tip: Check Console for detailed error messages');
        }
      })();
    });
  </script>
</body>
</html>

