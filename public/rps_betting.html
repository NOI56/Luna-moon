<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Luna Rock Paper Scissors - Betting Mode</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', 'Monaco', monospace;
      background: #0a0a0a;
      background-image: 
        radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #16213e 100%);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 20px;
      color: #00ffff;
      position: relative;
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0, 255, 255, 0.03) 2px,
          rgba(0, 255, 255, 0.03) 4px
        );
      pointer-events: none;
      z-index: 0;
    }

    .game-container {
      text-align: center;
      padding: 40px;
      padding-top: 100px;
      background: rgba(10, 10, 26, 0.8);
      border: none;
      border-radius: 0;
      box-shadow: 
        0 0 20px rgba(0, 255, 255, 0.25),
        0 0 40px rgba(0, 255, 255, 0.15),
        inset 0 0 20px rgba(0, 255, 255, 0.05);
      max-width: 1000px;
      width: 100%;
      position: relative;
      z-index: 1;
      margin-top: 20px;
    }
    
    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #00ffff, #00ffff, #00ffff);
      z-index: -1;
      animation: borderGlow 3s ease-in-out infinite;
      opacity: 0.5;
    }
    
    @keyframes borderGlow {
      0%, 100% { opacity: 0.15; }
      50% { opacity: 0.35; }
    }

    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      color: #00ffff;
      text-shadow: 
        0 0 5px #00ffff,
        0 0 10px #00ffff,
        0 0 15px #00ffff,
        2px 2px 4px rgba(0, 0, 0, 0.8);
      font-weight: bold;
      letter-spacing: 3px;
      text-transform: uppercase;
      animation: textGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes textGlow {
      0% { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 15px #00ffff; }
      100% { text-shadow: 0 0 10px #00ffff, 0 0 15px #00ffff, 0 0 20px #00ffff; }
    }

    .subtitle {
      font-size: 1.2em;
      margin-bottom: 30px;
      color: #00ffff;
      text-shadow: 0 0 5px #00ffff;
    }

    .back-link {
      /* Removed position/left/top to allow inline styles to work */
      color: #00ffff;
      text-decoration: none;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      transition: all 0.3s;
    }

    .back-link:hover {
      background: rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 10px #00ffff;
    }
    
    /* Ensure mode navigation is always visible */
    #modeNavigation {
      position: fixed !important;
      top: 40px !important;
      left: 20px !important;
      z-index: 99999 !important;
      display: flex !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    
    #modeNavigation a {
      display: inline-block !important;
      visibility: visible !important;
      opacity: 1 !important;
      cursor: pointer !important;
    }
    
    #modeNavigation a:hover {
      box-shadow: 
        0 0 20px currentColor,
        0 0 40px currentColor,
        0 0 60px currentColor,
        inset 0 0 20px rgba(255, 255, 255, 0.1) !important;
      transform: scale(1.05) !important;
      text-shadow: 
        0 0 10px currentColor,
        0 0 20px currentColor,
        0 0 30px currentColor !important;
      background: rgba(0, 0, 0, 0.95) !important;
    }
    
    #modeNavigation a:active {
      box-shadow: 
        0 0 30px currentColor,
        0 0 60px currentColor,
        0 0 90px currentColor,
        inset 0 0 30px rgba(255, 255, 255, 0.2) !important;
      transform: scale(0.98) !important;
    }

    /* Wallet Connect Button (Fixed Position - Top Right) */
    #walletConnectFixed {
      position: fixed;
      top: 40px;
      right: 20px;
      z-index: 99999;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
    }

    #walletConnectFixed .wallet-btn {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ffff;
      color: #00ffff;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      transition: all 0.3s;
      backdrop-filter: blur(5px);
      white-space: nowrap;
    }

    #walletConnectFixed .wallet-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 10px #00ffff;
    }

    #walletConnectFixed .wallet-info {
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 8px 15px;
      border-radius: 8px;
      font-size: 0.85em;
      backdrop-filter: blur(5px);
      max-width: 250px;
      word-break: break-all;
    }

    /* Neon Toggle Button (Bottom Right) */
    #neonToggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 99999;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ffff;
      color: #00ffff;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      transition: all 0.3s;
      backdrop-filter: blur(5px);
    }

    #neonToggle:hover {
      background: rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 10px #00ffff;
    }

    /* Neon Off Styles */
    body.neon-off * {
      text-shadow: none !important;
      box-shadow: none !important;
      filter: none !important;
      animation: none !important;
    }

    body.neon-off .game-container::before {
      display: none !important;
    }

    body.neon-off body::before {
      opacity: 0.01 !important;
    }

    .wallet-connect {
      margin-bottom: 30px;
    }

    .wallet-btn {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.2));
      border: none;
      color: #00ffff;
      padding: 15px 30px;
      font-size: 1.1em;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s;
      font-family: 'Courier New', monospace;
      margin: 5px;
    }

    .wallet-btn:hover {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.4));
        box-shadow: 0 0 10px #00ffff;
      transform: scale(1.05);
    }

    .wallet-info {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid #00ffff;
      border-radius: 8px;
      font-size: 0.9em;
    }

    .balance-check {
      margin: 15px 0;
      padding: 10px;
      color: #00ffff;
    }

    .betting-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-top: 30px;
    }

    .create-room, .available-rooms {
      background: rgba(0, 255, 255, 0.05);
      border: none;
      border-radius: 8px;
      padding: 25px;
    }

    .create-room h2, .available-rooms h2 {
      color: #00ffff;
      margin-bottom: 20px;
      font-size: 1.5em;
      text-shadow: 0 0 5px #00ffff;
    }

    .bet-input {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 20px;
    }

    .bet-input label {
      color: #00ffff;
      font-size: 1.1em;
    }

    .bet-input input {
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: #00ffff;
      padding: 12px;
      font-size: 1.2em;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      text-align: center;
    }

    .bet-input input:focus {
      outline: none;
      box-shadow: 0 0 15px #00ffff;
    }

    .create-btn {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.3));
      border: none;
      color: #00ffff;
      padding: 15px 30px;
      font-size: 1.2em;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s;
      font-family: 'Courier New', monospace;
      width: 100%;
    }

    .create-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(0, 255, 255, 0.5));
      box-shadow: 0 0 25px #00ffff;
      transform: scale(1.05);
    }

    .create-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .rooms-list {
      max-height: 400px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .room-card {
      background: rgba(0, 255, 255, 0.1);
      border: none;
      border-radius: 8px;
      padding: 20px;
      transition: all 0.3s;
    }

    .room-card:hover {
      background: rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 10px #00ffff;
      transform: translateX(5px);
    }

    .room-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .room-bet {
      font-size: 1.3em;
      color: #00ffff;
      font-weight: bold;
      text-shadow: 0 0 5px #00ffff;
    }

    .room-creator {
      font-size: 0.9em;
      color: #00ffff;
      opacity: 0.8;
    }

    .room-status {
      margin: 10px 0;
      color: #00ffff;
    }

    .join-btn {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.3));
      border: none;
      color: #00ffff;
      padding: 12px 25px;
      font-size: 1.1em;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s;
      font-family: 'Courier New', monospace;
      width: 100%;
      margin-top: 10px;
    }

    .join-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(0, 255, 255, 0.5));
      box-shadow: 0 0 25px #00ffff;
      transform: scale(1.05);
    }

    .join-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .game-area {
      display: none;
      margin-top: 30px;
    }

    .game-area.active {
      display: block;
    }

    .hands-container {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 40px 0;
      gap: 30px;
    }

    .hand {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .hand-label {
      font-size: 1.3em;
      color: #00ffff;
      text-shadow: 0 0 5px #00ffff;
      font-weight: bold;
    }

    .hand-icon {
      width: 150px;
      height: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3px solid #00ffff;
      border-radius: 50%;
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.25);
    }

    .hand-icon img {
      width: 120px;
      height: 120px;
      object-fit: contain;
    }

    #playerHand img {
      transform: scaleX(1) rotate(90deg);
    }

    #opponentHand img {
      transform: scaleX(1) rotate(-90deg);
    }
    
    .choice-btn {
      font-size: 0; /* Remove emoji font size */
    }
    
    .choice-btn img {
      width: 80px;
      height: 80px;
      object-fit: contain;
      display: block;
    }

    .vs {
      font-size: 2em;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
      font-weight: bold;
    }

    .result {
      font-size: 2em;
      margin: 30px 0;
      padding: 20px;
      background: rgba(0, 255, 255, 0.1);
      border: none;
      border-radius: 8px;
      min-height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .player-choices {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 30px 0;
    }

    .choice-btn {
      width: 120px;
      height: 120px;
      border: 3px solid #00ffff;
      border-radius: 50%;
      background: rgba(0, 255, 255, 0.1);
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3em;
      color: #00ffff;
      position: relative;
      overflow: hidden;
    }

    .choice-btn:hover:not(:disabled) {
      background: rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 30px #00ffff;
      transform: scale(1.1);
    }

    .choice-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .status {
      margin-top: 20px;
      font-size: 1.2em;
      color: #00ffff;
      min-height: 30px;
    }

    .hidden {
      display: none !important;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .empty-rooms {
      text-align: center;
      color: #00ffff;
      opacity: 0.6;
      padding: 40px;
      font-size: 1.1em;
    }

    @media (max-width: 768px) {
      .betting-section {
        grid-template-columns: 1fr;
      }
    }
    
    .countdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      pointer-events: none;
    }
    
    .countdown-number {
      font-size: 15em;
      font-weight: bold;
      color: #00ffff;
      text-shadow: 
        0 0 20px #00ffff,
        0 0 40px #00ffff,
        0 0 60px #00ffff,
        0 0 80px #00ffff;
      animation: countdownPulse 0.8s ease-out;
    }
    
    @keyframes countdownPulse {
      0% {
        transform: scale(0.5);
        opacity: 0;
      }
      50% {
        transform: scale(1.2);
        opacity: 1;
      }
      100% {
        transform: scale(1);
        opacity: 0.8;
      }
    }

    /* Contract Address Section */
    .contract-section {
      background: rgba(0, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      text-align: center;
    }

    .contract-label {
      font-size: 1rem;
      color: #00ffff;
      margin-bottom: 15px;
      font-weight: bold;
      text-shadow: 0 0 5px #00ffff;
    }

    .contract-input-group {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }

    .contract-input {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(0, 255, 255, 0.3);
      color: #00ffff;
      padding: 12px 20px;
      font-size: 0.9rem;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      min-width: 300px;
      max-width: 100%;
      flex: 1;
    }

    .contract-input:focus {
      outline: none;
      box-shadow: 0 0 15px #00ffff;
    }

    .contract-btn {
      padding: 12px 24px;
      font-size: 0.9rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }

    .contract-btn-copy {
      background: linear-gradient(135deg, #ff6b35, #ff8c42);
      color: white;
      font-weight: bold;
    }

    .contract-btn-copy:hover {
      background: linear-gradient(135deg, #ff8c42, #ff6b35);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
      transform: translateY(-2px);
    }

    .contract-btn-view {
      background: linear-gradient(135deg, #1a237e, #283593);
      color: white;
      font-weight: bold;
    }

    .contract-btn-view:hover {
      background: linear-gradient(135deg, #283593, #3949ab);
      box-shadow: 0 0 15px rgba(26, 35, 126, 0.5);
      transform: translateY(-2px);
    }

    .contract-warning {
      font-size: 0.85rem;
      color: #00ffff;
      opacity: 0.8;
      margin-top: 15px;
    }

    /* X DEX Links Section */
    .dex-links {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 20px 0;
    }

    .dex-btn {
      padding: 15px 30px;
      font-size: 1.1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 10px;
      text-decoration: none;
      white-space: nowrap;
    }

    .dex-btn-buy {
      background: linear-gradient(135deg, #ff6b35, #ff8c42);
      color: white;
    }

    .dex-btn-buy:hover {
      background: linear-gradient(135deg, #ff8c42, #ff6b35);
      box-shadow: 0 0 20px rgba(255, 107, 53, 0.6);
      transform: translateY(-2px);
    }

    .dex-btn-community {
      background: linear-gradient(135deg, #1a237e, #283593);
      color: white;
    }

    .dex-btn-community:hover {
      background: linear-gradient(135deg, #283593, #3949ab);
      box-shadow: 0 0 20px rgba(26, 35, 126, 0.6);
      transform: translateY(-2px);
    }

    @media (max-width: 768px) {
      .contract-input-group {
        flex-direction: column;
      }

      .contract-input {
        min-width: 100%;
      }

      .dex-links {
        flex-direction: column;
      }

      .dex-btn {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div id="modeNavigation" style="position: fixed !important; top: 40px !important; left: 20px !important; display: flex !important; gap: 10px; z-index: 99999 !important; flex-wrap: wrap; pointer-events: auto !important; visibility: visible !important; opacity: 1 !important;">
    <a href="/rps_vs_luna.html" id="vsLunaLink" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important;">üéÆ VS Luna</a>
    <a href="/rps_game.html" id="pvpLink" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important;">Play PvP! Find</a>
    <a href="/rps_betting.html" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important;">üí∞ Betting Mode</a>
    <a href="/rps_deposit.html" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important;">üíæ Deposit Luna</a>
    <a href="/group_chat.html" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 255, 255, 0.2) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important; box-shadow: 0 0 15px rgba(0, 255, 255, 0.5) !important;">üí¨ Group Chat</a>
    <a href="/rps_leaderboard.html" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important;">üèÜ Leaderboard</a>
    <a href="/rps_stats.html" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important;">üìä Stats</a>
    <a href="/rps_history.html" style="color: #00ffff !important; text-decoration: none !important; padding: 10px 20px !important; border: 2px solid #00ffff !important; border-radius: 8px !important; transition: all 0.3s; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(5px); display: inline-block !important; visibility: visible !important; opacity: 1 !important;">üìú Match History</a>
    <!-- Notification button will be added here by JavaScript -->
  </div>

  <!-- Fixed Wallet Connect (Top Right) -->
  <div id="walletConnectFixed">
    <button id="connectWalletBtnFixed" class="wallet-btn">üîó Connect Phantom Wallet</button>
    <button id="disconnectWalletBtnFixed" class="wallet-btn disconnect-btn hidden">üîå Disconnect / Change Wallet</button>
    <div id="walletInfoFixed" class="wallet-info hidden"></div>
  </div>

  <!-- Neon Toggle Button (Bottom Right) -->
  <button id="neonToggle" title="Toggle Neon Effects">üí° Neon: ON</button>

  <div class="game-container">
    <h1>Rock Paper Scissors</h1>
    <div class="subtitle">üí∞ Betting Mode - Create or Join a Room</div>
    
    <!-- Contract Address Section -->
    <div class="contract-section">
      <div class="contract-label">Contract Address:</div>
      <div class="contract-input-group">
        <input type="text" id="contractAddress" class="contract-input" readonly value="Loading...">
        <button class="contract-btn contract-btn-copy" onclick="copyContractAddress()">
          <span>üìã</span> Copy
        </button>
        <button class="contract-btn contract-btn-view" onclick="viewContractAddress()">
          <span>üîó</span> View
        </button>
      </div>
      <div class="contract-warning">Always verify the contract address before buying.</div>
    </div>

    <!-- X DEX Links Section -->
    <div class="dex-links">
      <a href="#" id="buyDexLink" class="dex-btn dex-btn-buy" target="_blank" onclick="openBuyDex(event)">
        <span>‚ö°</span> Buy Luna
      </a>
      <a href="#" id="communityLink" class="dex-btn dex-btn-community" target="_blank" onclick="openCommunity(event)">
        <span>ùïè</span> Join Community
      </a>
    </div>
    
    <!-- Weekly Competition Timer -->
    <div id="competitionTimer" style="margin: 20px 0; padding: 20px; background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.2)); border: 2px solid #00ffff; border-radius: 12px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);">
      <div style="font-size: 1.1em; color: #00ffff; margin-bottom: 10px; font-weight: bold; text-shadow: 0 0 10px #00ffff;">
        üèÜ Weekly Competition
      </div>
      <div style="font-size: 1.5em; color: #00ffff; font-weight: bold; text-shadow: 0 0 15px #00ffff; font-family: 'Courier New', monospace;">
        <span id="timerDays">0</span>d 
        <span id="timerHours">0</span>h 
        <span id="timerMinutes">0</span>m 
        <span id="timerSeconds">0</span>s
      </div>
      <div style="font-size: 0.9em; color: #00ffff; margin-top: 10px; opacity: 0.8;">
        Time remaining until rewards distribution
      </div>
    </div>

    <div id="walletConnect" class="wallet-connect" style="display: none;">
      <button id="connectWalletBtn" class="wallet-btn">üîó Connect Phantom Wallet</button>
      <button id="disconnectWalletBtn" class="wallet-btn disconnect-btn hidden">üîå Disconnect / Change Wallet</button>
      <div id="walletInfo" class="wallet-info hidden"></div>
    </div>
    <div id="balanceCheck" class="balance-check hidden">
      <span class="loading"></span> Checking balance...
    </div>
    <div id="solBalanceDisplay" class="wallet-info hidden" style="margin-top: 10px; padding: 15px; background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff; border-radius: 8px; font-size: 0.9em; color: #00ffff;">
      <strong>üí∞ SOL Balance:</strong> <span id="solBalanceAmount">0.0000</span> SOL
    </div>

    <!-- Total Fees Display (Real-time) -->
    <div id="totalFeesDisplay" style="margin-top: 15px; padding: 15px; background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff; border-radius: 8px; font-size: 0.9em; color: #00ffff;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <strong>üíé Total Fees Collected (Real-time):</strong>
        <span id="totalFeesAmount" style="font-size: 1.2em; font-weight: bold; color: #00ffff; text-shadow: 0 0 5px #00ffff;">0.0000</span>
        <span style="color: #00ffff; opacity: 0.8;">SOL</span>
      </div>
      <div style="font-size: 0.85em; opacity: 0.8; margin-top: 5px;">
        <span id="totalFeesTransactions">0</span> transactions ‚Ä¢ Last updated: <span id="lastFeesUpdate">--</span>
      </div>
      <div style="font-size: 0.85em; opacity: 0.7; margin-top: 5px; color: #00ffff;">
        üí° Fees are automatically sent to: <span id="feeWalletAddress" style="font-family: monospace;">--</span>
      </div>
    </div>

    <!-- Deposit/Withdraw Section -->
    <div id="depositSection" class="deposit-section hidden" style="margin: 20px 0; padding: 20px; background: rgba(0, 255, 255, 0.05); border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 8px;">
      <h3 style="color: #00ffff; margin-bottom: 15px; text-shadow: 0 0 5px #00ffff;">üí∞ Deposit Luna (Reduce Betting Fee)</h3>
      <div style="font-size: 0.9em; color: #00ffff; opacity: 0.8; margin-bottom: 15px;">
        Hold 150,000+ Luna to deposit. Deposit for 3 days ‚Üí 2% fee, 6 days ‚Üí 1% fee (default: 3%)
      </div>
      
      <!-- Deposit Status -->
      <div id="depositStatus" style="margin-bottom: 15px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 8px;">
        <div style="color: #00ffff; font-size: 0.9em;">Checking deposit status...</div>
      </div>
      
      <!-- Deposit Form -->
      <div id="depositForm" style="display: none;">
        <div style="margin-bottom: 15px;">
          <label style="color: #00ffff; display: block; margin-bottom: 5px;">Deposit Amount (Luna):</label>
          <input type="number" id="depositAmount" min="1" placeholder="Enter amount" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 1px solid #00ffff; border-radius: 8px; color: #00ffff; font-family: 'Courier New', monospace; font-size: 1em;">
          <div style="font-size: 0.85em; color: #00ffff; opacity: 0.7; margin-top: 5px;">
            Fee: 3% (will be deducted from amount)
          </div>
        </div>
        <button id="depositBtn" class="wallet-btn" style="width: 100%;">üíæ Deposit Luna</button>
      </div>
      
      <!-- Withdraw Button -->
      <button id="withdrawBtn" class="wallet-btn" style="width: 100%; margin-top: 10px; display: none; background: linear-gradient(135deg, rgba(255, 0, 0, 0.3), rgba(255, 100, 100, 0.3)); border: 2px solid #ff0000; color: #ff0000;">
        üí∏ Withdraw Luna
      </button>
    </div>

    <div id="bettingSection" class="betting-section">
      <!-- Create Room Section -->
      <div class="create-room">
        <h2>üéÆ Create Room</h2>
        <div class="bet-input">
          <label for="betAmount">Bet Amount (Luna tokens):</label>
          <input type="number" id="betAmount" min="1" placeholder="Enter amount" oninput="updateFeeDisplay()" />
          <div id="feeDisplay" style="margin-top: 10px; padding: 10px; background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff; border-radius: 8px; font-size: 0.9em; color: #00ffff; display: none;">
            <div>üí∞ Fee: <span id="feeAmount">0</span> SOL (<span id="feePercentageDisplay">3%</span> of bet value)</div>
            <div style="font-size: 0.85em; opacity: 0.8; margin-top: 5px;">Bet value: <span id="betValueInSol">0</span> SOL</div>
          </div>
        </div>
        <button id="createRoomBtn" class="create-btn" disabled>Create Room</button>
      </div>

      <!-- Available Rooms Section -->
      <div class="available-rooms">
        <h2>üèÜ Available Rooms</h2>
        <div id="roomsList" class="rooms-list">
          <div class="empty-rooms">Loading rooms...</div>
        </div>
        <div style="margin-top: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff; border-radius: 8px; font-size: 0.9em; color: #00ffff;">
        </div>
      </div>
    </div>

    <!-- Referral Section Placeholder -->
    <div id="referral-section-placeholder"></div>

    <!-- Game Area (shown when match starts) -->
    <div id="gameArea" class="game-area">
      <div class="hands-container">
        <div class="hand">
          <div class="hand-label">You</div>
          <div id="playerHand" class="hand-icon"></div>
        </div>
        <div class="vs">VS</div>
        <div class="hand">
          <div class="hand-label" id="opponentLabel">Opponent</div>
          <div id="opponentHand" class="hand-icon"></div>
        </div>
      </div>

      <div id="result" class="result"></div>

      <div class="controls">
        <div class="player-choices">
          <button class="choice-btn" data-choice="rock" id="rockBtn">
            <img src="/public/images/hands/rock.png" alt="rock" />
          </button>
          <button class="choice-btn" data-choice="paper" id="paperBtn">
            <img src="/public/images/hands/paper.png" alt="paper" />
          </button>
          <button class="choice-btn" data-choice="scissors" id="scissorsBtn">
            <img src="/public/images/hands/scissors.png" alt="scissors" />
          </button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <script>
    const API_BASE = window.location.origin;
    const TEST_MODE = false; // Using real Luna token
    // Mint address will be read from backend (.env) automatically
    // No need to hardcode here
    
    // Security: HTML Sanitization function
    function escapeHtml(text) {
      if (text == null) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Security: Sanitize wallet address for display
    function sanitizeWalletAddress(address) {
      if (!address || typeof address !== 'string') return '';
      // Remove any non-alphanumeric characters except base58 chars
      return address.replace(/[^A-Za-z0-9]/g, '').substring(0, 44);
    }
    
    // Security: Create safe HTML element
    function createSafeElement(tag, text, className = '') {
      const el = document.createElement(tag);
      if (className) el.className = className;
      el.textContent = text;
      return el;
    }
    
    // Fee calculation constants
    const FEE_PERCENTAGE = 0.01; // 1% fee
    let LUNA_TO_SOL_RATE = 0.00009; // Will be fetched from backend
    let priceCacheTime = 0;
    const PRICE_CACHE_TTL = 60000; // 1 minute cache
    let walletConnected = false;
    let walletPublicKey = null;
    let currentRoomId = null;
    let opponentWallet = null;
    let gameActive = false;
    let ws = null;
    let roomsRefreshInterval = null;
    let handCycleInterval = null;
    let countdownInterval = null;
    let balanceUpdateInterval = null;
    let solBalanceUpdateInterval = null;
    let solBalance = 0;
    let competitionTimerInterval = null;

    // Sound Effects System
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Play sound effect
    function playSound(frequency, duration, type = 'sine', volume = 0.3) {
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      } catch (e) {
        console.error('[Sound] Error playing sound:', e);
      }
    }
    
    // Countdown sound (beep)
    function playCountdownSound() {
      playSound(800, 0.1, 'sine', 0.2);
    }
    
    // Win sound (cheer - multiple beeps)
    function playWinSound() {
      // Play multiple ascending notes
      playSound(523, 0.15, 'sine', 0.3); // C
      setTimeout(() => playSound(659, 0.15, 'sine', 0.3), 100); // E
      setTimeout(() => playSound(784, 0.2, 'sine', 0.4), 200); // G
      setTimeout(() => playSound(1047, 0.3, 'sine', 0.5), 350); // C (high)
    }
    
    // Lose sound (sad descending)
    function playLoseSound() {
      // Play descending notes
      playSound(523, 0.2, 'sine', 0.3); // C
      setTimeout(() => playSound(440, 0.2, 'sine', 0.3), 150); // A
      setTimeout(() => playSound(349, 0.3, 'sine', 0.4), 300); // F (low)
    }
    
    // Tie sound (neutral)
    function playTieSound() {
      // Play a neutral tone
      playSound(440, 0.2, 'sine', 0.25); // A
      setTimeout(() => playSound(440, 0.2, 'sine', 0.25), 200); // A again
    }

    const HAND_IMAGES = {
      rock: '/public/images/hands/rock.png',
      paper: '/public/images/hands/paper.png',
      scissors: '/public/images/hands/scissors.png',
      default: '/public/images/hands/rock.png'
    };

    // Wallet Connection
    async function setupWalletConnection() {
      const connectBtn = document.getElementById('connectWalletBtn');
      const disconnectBtn = document.getElementById('disconnectWalletBtn');
      const walletInfo = document.getElementById('walletInfo');

      if (!connectBtn) {
        console.error('[Betting] connectWalletBtn not found!');
        return;
      }

      // Check if Phantom wallet is available
      if (typeof window.solana === 'undefined' || !window.solana.isPhantom) {
        connectBtn.textContent = '‚ö†Ô∏è Phantom Wallet not found!';
        connectBtn.disabled = true;
        connectBtn.style.cursor = 'not-allowed';
        connectBtn.onclick = () => {
          alert('Please install Phantom wallet extension!\n\nDownload: https://phantom.app/');
        };
        return;
      }

      // Enable button and add click handler
      connectBtn.disabled = false;
      connectBtn.style.cursor = 'pointer';
      
      const connectHandler = async () => {
        try {
          console.log('[Betting] Connect button clicked');
          
          if (!window.solana || !window.solana.isPhantom) {
            alert('‚ö†Ô∏è Phantom wallet not found!\n\nPlease install Phantom wallet extension:\nhttps://phantom.app/\n\nAfter installing, refresh this page.');
            return;
          }
          
          // Additional check: verify Phantom is ready
          if (typeof window.solana.connect !== 'function') {
            alert('‚ö†Ô∏è Phantom wallet extension is not ready!\n\nPlease:\n1. Make sure Phantom wallet is unlocked\n2. Refresh this page\n3. Try again');
            return;
          }
          
          // ALWAYS disconnect first to force popup (like pump.fun)
          console.log('[Betting] Disconnecting wallet first to force popup...');
          try {
            if (window.solana.isConnected) {
              await window.solana.disconnect();
              console.log('[Betting] Wallet disconnected');
            }
            // Wait briefly to ensure disconnect is complete (reduced from 2000ms to 300ms for faster popup)
            console.log('[Betting] Waiting 300ms to clear cached connection...');
            await new Promise(resolve => setTimeout(resolve, 300));
          } catch (disconnectErr) {
            console.warn('[Betting] Error during disconnect:', disconnectErr);
            await new Promise(resolve => setTimeout(resolve, 300));
          }
          
          // Step 1: Connect wallet (like pump.fun)
          console.log('[Betting] Step 1: Connecting wallet...');
          console.log('[Betting] ‚ö†Ô∏è CONNECT POPUP SHOULD APPEAR NOW! ‚ö†Ô∏è');
          console.log('[Betting] If popup does NOT appear:');
          console.log('[Betting] 1. Phantom wallet has this site in Trusted Apps');
          console.log('[Betting] 2. Go to Phantom wallet ‚Üí Settings ‚Üí Trusted Apps');
          console.log('[Betting] 3. Remove "localhost:8787" from trusted apps');
          console.log('[Betting] 4. Refresh page and try again');
          
          const resp = await window.solana.connect({ onlyIfTrusted: false });
          
          if (!resp || !resp.publicKey) {
            throw new Error('Connection failed: No public key returned');
          }
          
          walletPublicKey = resp.publicKey.toString();
          console.log('[Betting] ‚úÖ Step 1 complete: Wallet connected:', walletPublicKey);
          
          // Step 2: Sign message to authenticate (like pump.fun)
          try {
            console.log('[Betting] Step 2: Requesting message signature for authentication...');
            console.log('[Betting] ‚ö†Ô∏è SIGN MESSAGE POPUP SHOULD APPEAR NOW! ‚ö†Ô∏è');
            console.log('[Betting] This is the authentication popup (like pump.fun)');
            console.log('[Betting] If this popup does NOT appear, Phantom wallet may have auto-approve enabled');
            
            // Create authentication message (like pump.fun)
            const timestamp = Date.now();
            const message = `Sign in to ${window.location.hostname}: ${timestamp}`;
            const messageBytes = new TextEncoder().encode(message);
            
            // Request signature using request() method (Phantom wallet API)
            let signResponse;
            if (typeof window.solana.request === 'function') {
              // Use request() method (recommended)
              signResponse = await window.solana.request({
                method: 'signMessage',
                params: {
                  message: messageBytes,
                  display: 'utf8'
                }
              });
            } else if (typeof window.solana.signMessage === 'function') {
              // Fallback to signMessage() method
              signResponse = await window.solana.signMessage(messageBytes, 'utf8');
            } else {
              throw new Error('signMessage method not available');
            }
            
            // Handle different response formats
            const signature = signResponse.signature || signResponse;
            const signatureArray = signature instanceof Uint8Array 
              ? Array.from(signature) 
              : (Array.isArray(signature) ? signature : []);
            
            console.log('[Betting] ‚úÖ Step 2 complete: Message signed successfully');
            console.log('[Betting] Signature received (length):', signatureArray.length);
            
            // Store signature in localStorage for session
            localStorage.setItem('walletSignature', JSON.stringify({
              signature: signatureArray,
              publicKey: walletPublicKey,
              timestamp: timestamp,
              message: message
            }));
            
            console.log('[Betting] ‚úÖ Authentication signature stored in localStorage');
            
          } catch (signErr) {
            console.error('[Betting] Sign message failed:', signErr);
            // Disconnect if sign fails
            try {
              await window.solana.disconnect();
            } catch (disconnectErr) {
              console.warn('[Betting] Error disconnecting after sign failure:', disconnectErr);
            }
            throw new Error('Authentication failed: Please sign the message to continue. ' + signErr.message);
          }
          
          walletConnected = true;
          console.log('[Betting] ‚úÖ Authentication complete! Wallet is now authenticated.');
          
          // Update container buttons
          connectBtn.classList.add('hidden');
          if (disconnectBtn) disconnectBtn.classList.remove('hidden');
          if (walletInfo) {
            walletInfo.classList.remove('hidden');
            const sanitizedWallet = sanitizeWalletAddress(walletPublicKey);
            const shortWallet = sanitizedWallet.length > 16 
              ? `${sanitizedWallet.substring(0, 8)}...${sanitizedWallet.substring(sanitizedWallet.length - 8)}`
              : sanitizedWallet;
            walletInfo.innerHTML = `
              <strong>Connected:</strong> ${escapeHtml(shortWallet)}<br>
              <strong>Balance:</strong> <span id="balanceDisplay">Checking...</span>
            `;
          }
          
          // Update fixed buttons
          const connectBtnFixed = document.getElementById('connectWalletBtnFixed');
          const disconnectBtnFixed = document.getElementById('disconnectWalletBtnFixed');
          const walletInfoFixed = document.getElementById('walletInfoFixed');
          if (connectBtnFixed) connectBtnFixed.classList.add('hidden');
          if (disconnectBtnFixed) {
            disconnectBtnFixed.classList.remove('hidden');
            disconnectBtnFixed.style.display = '';
            disconnectBtnFixed.style.visibility = '';
            disconnectBtnFixed.style.opacity = '';
          }
          if (walletInfoFixed) {
            const sanitizedWallet = sanitizeWalletAddress(walletPublicKey);
            const shortWallet = sanitizedWallet.length > 16 
              ? `${sanitizedWallet.substring(0, 8)}...${sanitizedWallet.substring(sanitizedWallet.length - 8)}`
              : sanitizedWallet;
            walletInfoFixed.innerHTML = `
              <div><strong>Connected:</strong> ${escapeHtml(shortWallet)}</div>
              <div><strong>Balance:</strong> <span id="balanceDisplayFixed">Checking...</span> Luna</div>
            `;
            walletInfoFixed.classList.remove('hidden');
            walletInfoFixed.style.display = '';
            walletInfoFixed.style.visibility = '';
            walletInfoFixed.style.opacity = '';
          }
          
          await checkLunaBalance();
          await checkSolBalance();
          await loadRooms();
          startBalanceUpdate(); // Start real-time balance updates
          startSolBalanceUpdate(); // Start real-time SOL balance updates
          setupDepositSystem(); // Setup deposit/withdraw system
          await checkDepositStatus(); // Check deposit status
          
          // Update fixed balance display
          const balanceDisplayFixed = document.getElementById('balanceDisplayFixed');
          if (balanceDisplayFixed) {
            balanceDisplayFixed.textContent = formatNumber(playerBalance);
          }
          
          // Initialize UI components
          if (typeof notificationManager !== 'undefined') {
            notificationManager.init(walletPublicKey);
          }
        } catch (err) {
          console.error('[Betting] Wallet connection error:', err);
          alert('Failed to connect wallet: ' + err.message);
        }
      };
      
      connectBtn.addEventListener('click', connectHandler);
      
      // Also set up fixed connect button
      const connectBtnFixed = document.getElementById('connectWalletBtnFixed');
      if (connectBtnFixed) {
        connectBtnFixed.addEventListener('click', connectHandler);
      }

      const disconnectHandler = () => {
        try {
          if (window.solana && window.solana.isConnected) {
            window.solana.disconnect();
          }
          stopBalanceUpdate(); // Stop real-time balance updates
          stopSolBalanceUpdate(); // Stop real-time SOL balance updates
          walletConnected = false;
          walletPublicKey = null;
          playerBalance = 0;
          
          // Clear signature when disconnected (like pump.fun - must sign again on reconnect)
          localStorage.removeItem('walletSignature');
          console.log('[Betting] Wallet disconnected - signature cleared. Must sign again on next connect.');
          
          // Update container buttons
          connectBtn.classList.remove('hidden');
          if (disconnectBtn) disconnectBtn.classList.add('hidden');
          if (walletInfo) walletInfo.classList.add('hidden');
          const createBtn = document.getElementById('createRoomBtn');
          if (createBtn) createBtn.disabled = true;
          currentRoomId = null;
          
          // Update fixed buttons
          const connectBtnFixed = document.getElementById('connectWalletBtnFixed');
          const disconnectBtnFixed = document.getElementById('disconnectWalletBtnFixed');
          const walletInfoFixed = document.getElementById('walletInfoFixed');
          if (connectBtnFixed) connectBtnFixed.classList.remove('hidden');
          if (disconnectBtnFixed) {
            disconnectBtnFixed.classList.add('hidden');
            disconnectBtnFixed.style.display = 'none';
            disconnectBtnFixed.style.visibility = 'hidden';
            disconnectBtnFixed.style.opacity = '0';
          }
          if (walletInfoFixed) {
            walletInfoFixed.classList.add('hidden');
            walletInfoFixed.style.display = 'none';
            walletInfoFixed.style.visibility = 'hidden';
            walletInfoFixed.style.opacity = '0';
          }
        } catch (err) {
          console.error('[Betting] Wallet disconnect error:', err);
        }
      };
      
      if (disconnectBtn) {
        disconnectBtn.addEventListener('click', disconnectHandler);
      }
      
      // Also set up fixed disconnect button
      const disconnectBtnFixed = document.getElementById('disconnectWalletBtnFixed');
      if (disconnectBtnFixed) {
        disconnectBtnFixed.addEventListener('click', disconnectHandler);
      }
    }

    async function checkLunaBalance() {
      const balanceCheck = document.getElementById('balanceCheck');
      const balanceDisplay = document.getElementById('balanceDisplay');
      if (balanceCheck) balanceCheck.classList.remove('hidden');
      
      if (!walletConnected || !walletPublicKey) {
        if (balanceDisplay) balanceDisplay.textContent = 'Not connected';
        if (balanceCheck) balanceCheck.classList.add('hidden');
        return;
      }

      try {
        // Use backend API to check balance (bypasses RPC rate limiting)
        // Backend will read mint address from .env automatically
        const response = await fetch(`${API_BASE}/luna/rps/balance?wallet=${walletPublicKey}`);
        const data = await response.json();
        
        if (!data.ok) {
          throw new Error(data.error || 'Failed to check balance');
        }
        
        playerBalance = data.balance || 0;
        
        if (balanceDisplay) {
          balanceDisplay.textContent = formatNumber(playerBalance) + ' Luna';
        }
        
        // Also update fixed balance display
        const balanceDisplayFixed = document.getElementById('balanceDisplayFixed');
        if (balanceDisplayFixed) {
          balanceDisplayFixed.textContent = formatNumber(playerBalance);
        }
        
        if (document.getElementById('createRoomBtn')) {
          document.getElementById('createRoomBtn').disabled = playerBalance < 1;
        }
        
        // Check deposit status after balance check
        await checkDepositStatus();
      } catch (err) {
        console.error('[Betting] Balance check error:', err);
        if (balanceDisplay) balanceDisplay.textContent = 'Error';
        if (document.getElementById('createRoomBtn')) {
          document.getElementById('createRoomBtn').disabled = true;
        }
        
        // Still try to check deposit status
        await checkDepositStatus();
      } finally {
        if (balanceCheck) balanceCheck.classList.add('hidden');
      }
    }

    // Start real-time balance updates
    function startBalanceUpdate() {
      // Clear existing interval if any
      if (balanceUpdateInterval) {
        clearInterval(balanceUpdateInterval);
      }
      
      // Update balance every 15 seconds (reduced frequency to avoid rate limiting)
      balanceUpdateInterval = setInterval(async () => {
        if (walletConnected && walletPublicKey) {
          await checkLunaBalance();
        }
      }, 15000);
    }

    // Stop real-time balance updates
    function stopBalanceUpdate() {
      if (balanceUpdateInterval) {
        clearInterval(balanceUpdateInterval);
        balanceUpdateInterval = null;
      }
    }

    // Check SOL Balance
    async function checkSolBalance() {
      const solBalanceDisplay = document.getElementById('solBalanceDisplay');
      const solBalanceAmount = document.getElementById('solBalanceAmount');
      
      if (!walletConnected || !walletPublicKey) {
        if (solBalanceDisplay) solBalanceDisplay.classList.add('hidden');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/luna/rps/sol/balance?wallet=${walletPublicKey}`);
        const data = await response.json();
        
        if (data.ok) {
          solBalance = data.balance || 0;
          if (solBalanceAmount) {
            solBalanceAmount.textContent = solBalance.toFixed(4);
          }
          if (solBalanceDisplay) {
            solBalanceDisplay.classList.remove('hidden');
          }
        } else {
          console.error('[Betting] SOL balance check error:', data.error);
        }
      } catch (err) {
        console.error('[Betting] SOL balance check error:', err);
      }
    }

    // Start real-time SOL balance updates
    function startSolBalanceUpdate() {
      // Clear existing interval if any
      if (solBalanceUpdateInterval) {
        clearInterval(solBalanceUpdateInterval);
      }
      
      // Update SOL balance every 10 seconds
      solBalanceUpdateInterval = setInterval(async () => {
        if (walletConnected && walletPublicKey) {
          await checkSolBalance();
        }
      }, 10000);
    }

    // Stop real-time SOL balance updates
    function stopSolBalanceUpdate() {
      if (solBalanceUpdateInterval) {
        clearInterval(solBalanceUpdateInterval);
        solBalanceUpdateInterval = null;
      }
    }

    function formatNumber(num) {
      return num.toLocaleString('en-US');
    }

    // Deposit/Withdraw System
    async function checkDepositStatus() {
      const depositSection = document.getElementById('depositSection');
      
      if (!walletConnected || !walletPublicKey) {
        if (depositSection) depositSection.classList.add('hidden');
        return;
      }
      
      // Show deposit section when wallet is connected
      if (depositSection) depositSection.classList.remove('hidden');

      try {
        const response = await fetch(`${API_BASE}/luna/deposit/status?wallet=${walletPublicKey}`);
        const data = await response.json();

        const depositStatus = document.getElementById('depositStatus');
        const depositForm = document.getElementById('depositForm');
        const withdrawBtn = document.getElementById('withdrawBtn');

        if (!depositSection) return;

        if (data.ok && data.hasDeposit) {
          depositForm.style.display = 'none';
          withdrawBtn.style.display = 'block';

          const deposit = data.deposit;
          depositStatus.innerHTML = `
            <div style="color: #00ffff; font-size: 0.9em;">
              <div style="margin-bottom: 5px;"><strong>üí∞ Deposited:</strong> ${formatNumber(deposit.amount)} Luna</div>
              <div style="margin-bottom: 5px;"><strong>üìÖ Days:</strong> ${deposit.daysSinceDeposit.toFixed(1)} days</div>
              <div style="margin-bottom: 5px;"><strong>üí∏ Betting Fee:</strong> ${deposit.feePercentageDisplay}</div>
              ${deposit.daysSinceDeposit >= 6 ? '<div style="color: #00ff00;">‚úÖ Maximum discount reached!</div>' : 
                deposit.daysSinceDeposit >= 3 ? '<div style="color: #ffff00;">‚è≥ Keep depositing for 1% fee!</div>' : 
                '<div style="color: #ffff00;">‚è≥ Keep depositing for lower fees!</div>'}
            </div>
          `;
        } else {
          depositForm.style.display = 'block';
          withdrawBtn.style.display = 'none';

          if (playerBalance < 150000) {
            depositStatus.innerHTML = `
              <div style="color: #ff0000; font-size: 0.9em;">
                ‚ùå You need at least 150,000 Luna to deposit.<br>
                Current: ${formatNumber(playerBalance)} Luna
              </div>
            `;
            depositForm.style.display = 'none';
          } else {
            depositStatus.innerHTML = `
              <div style="color: #00ffff; font-size: 0.9em;">
                ‚úÖ You can deposit Luna to reduce Betting Mode fees!<br>
                Deposit for 3 days ‚Üí 2% fee, 6 days ‚Üí 1% fee (default: 3%)
              </div>
            `;
          }
        }
      } catch (error) {
        console.error('[Deposit] Error checking deposit status:', error);
        // Keep section visible even on error, just show error message
        const depositStatus = document.getElementById('depositStatus');
        if (depositSection) depositSection.classList.remove('hidden');
        if (depositStatus) {
          depositStatus.innerHTML = `
            <div style="color: #ff0000; font-size: 0.9em;">
              ‚ö†Ô∏è Error checking deposit status. Please try again.
            </div>
          `;
        }
      }
    }

    function setupDepositSystem() {
      const depositBtn = document.getElementById('depositBtn');
      const withdrawBtn = document.getElementById('withdrawBtn');

      if (depositBtn) {
        depositBtn.addEventListener('click', async () => {
          if (!walletConnected || !walletPublicKey) {
            alert('Please connect your wallet first!');
            return;
          }

          const amount = parseFloat(document.getElementById('depositAmount').value);
          if (!amount || amount <= 0) {
            alert('Please enter a valid deposit amount!');
            return;
          }

          if (playerBalance < 150000) {
            alert(`You need at least 150,000 Luna to deposit. Current: ${formatNumber(playerBalance)} Luna`);
            return;
          }

          try {
            depositBtn.disabled = true;
            depositBtn.textContent = 'Processing...';

            const response = await fetch(`${API_BASE}/luna/deposit`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                wallet: walletPublicKey,
                amount: amount,
              }),
            });

            const data = await response.json();

            if (data.ok) {
              alert(`Deposit recorded! Please send ${amount} Luna to the escrow wallet.\n\nEscrow Wallet: ${data.deposit.escrowWallet}\n\nNote: ${data.note}`);
              document.getElementById('depositAmount').value = '';
              await checkDepositStatus();
              await checkLunaBalance();
            } else {
              alert('Failed to deposit: ' + (data.message || data.error));
            }
          } catch (error) {
            console.error('[Deposit] Error:', error);
            alert('Failed to deposit: ' + error.message);
          } finally {
            depositBtn.disabled = false;
            depositBtn.textContent = 'üíæ Deposit Luna';
          }
        });
      }

      if (withdrawBtn) {
        withdrawBtn.addEventListener('click', async () => {
          if (!walletConnected || !walletPublicKey) {
            alert('Please connect your wallet first!');
            return;
          }

          if (!confirm('Are you sure you want to withdraw? Your Betting Mode fee will return to 3%.')) {
            return;
          }

          try {
            withdrawBtn.disabled = true;
            withdrawBtn.textContent = 'Processing...';

            const response = await fetch(`${API_BASE}/luna/withdraw`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                wallet: walletPublicKey,
              }),
            });

            const data = await response.json();

            if (data.ok) {
              alert(`Withdrawal successful! ${formatNumber(data.withdrawal.amount)} Luna sent to your wallet.\n\nTransaction: ${data.withdrawal.signature}`);
              await checkDepositStatus();
              await checkLunaBalance();
            } else {
              alert('Failed to withdraw: ' + (data.message || data.error));
            }
          } catch (error) {
            console.error('[Withdraw] Error:', error);
            alert('Failed to withdraw: ' + error.message);
          } finally {
            withdrawBtn.disabled = false;
            withdrawBtn.textContent = 'üí∏ Withdraw Luna';
          }
        });
      }
    }

    /**
     * Fetch Luna price from backend
     */
    async function fetchLunaPrice() {
      const now = Date.now();
      // Use cache if available and not expired
      if (priceCacheTime > 0 && (now - priceCacheTime) < PRICE_CACHE_TTL) {
        return LUNA_TO_SOL_RATE;
      }

      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/price`);
        const data = await response.json();
        
        if (data.ok && data.price) {
          LUNA_TO_SOL_RATE = data.price;
          priceCacheTime = now;
          console.log(`[Betting] Fetched Luna price: ${LUNA_TO_SOL_RATE.toFixed(9)} SOL per Luna`);
          return LUNA_TO_SOL_RATE;
        } else {
          console.warn('[Betting] Failed to fetch price, using cached/default rate');
          return LUNA_TO_SOL_RATE;
        }
      } catch (error) {
        console.error('[Betting] Error fetching price:', error);
        return LUNA_TO_SOL_RATE; // Use cached/default rate
      }
    }

    /**
     * Convert Luna tokens to SOL value
     */
    function lunaToSol(lunaAmount) {
      return lunaAmount * LUNA_TO_SOL_RATE;
    }

    /**
     * Calculate 1% fee in SOL from Luna bet amount
     */
    function calculateFee(lunaAmount) {
      const solValue = lunaToSol(lunaAmount);
      return solValue * FEE_PERCENTAGE;
    }

    /**
     * Format SOL amount for display
     */
    function formatSol(amount) {
      if (amount < 0.000001) {
        return amount.toFixed(9) + ' SOL';
      } else if (amount < 0.001) {
        return amount.toFixed(6) + ' SOL';
      } else {
        return amount.toFixed(4) + ' SOL';
      }
    }

    // WebSocket Connection
    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}`;
      
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        console.log('[Betting] WebSocket connected');
      };
      
      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleWebSocketMessage(message);
        } catch (err) {
          console.error('[Betting] WebSocket message error:', err);
        }
      };
      
      ws.onerror = (error) => {
        console.error('[Betting] WebSocket error:', error);
      };
      
      ws.onclose = () => {
        console.log('[Betting] WebSocket disconnected, reconnecting...');
        setTimeout(connectWebSocket, 3000);
      };
    }

    function handleWebSocketMessage(message) {
      console.log('[Betting] WebSocket message:', message);
      
      if (message.type === 'rps_betting_room_created') {
        loadRooms();
      } else if (message.type === 'rps_betting_room_joined') {
        if (message.roomId === currentRoomId) {
          opponentWallet = message.opponent;
          startGame();
        }
        loadRooms();
      } else if (message.type === 'rps_betting_room_cancelled') {
        loadRooms();
        // If we're in this room, reset UI
        if (currentRoomId === message.roomId) {
          alert('Room was cancelled.');
          currentRoomId = null;
          gameActive = false;
          document.getElementById('bettingSection').classList.remove('hidden');
          document.getElementById('gameArea').classList.remove('active');
        }
      } else if (message.type === 'rps_betting_room_removed') {
        loadRooms();
        // If we're in this room, reset UI
        if (currentRoomId === message.roomId) {
          alert('Room expired or was removed.');
          currentRoomId = null;
          gameActive = false;
          document.getElementById('bettingSection').classList.remove('hidden');
          document.getElementById('gameArea').classList.remove('active');
        }
      } else if (message.type === 'rps_betting_match_result') {
        if (message.roomId === currentRoomId) {
          handleMatchResult(message);
        }
      }
    }

    // Room Management
    async function loadRooms() {
      // Always show test rooms in TEST_MODE
      if (TEST_MODE) {
        const testRooms = [
          {
            roomId: 'test_room_1',
            creator: '7xKXt...9mP2Q',
            betAmount: 10000,
            player2: null,
            timestamp: Date.now() - 30000,
            isTest: true
          },
          {
            roomId: 'test_room_2',
            creator: '5yLZu...3nR8T',
            betAmount: 50000,
            player2: null,
            timestamp: Date.now() - 60000,
            isTest: true
          }
        ];
        displayRooms(testRooms);
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/rooms`);
        const data = await response.json();
        
        if (data.ok) {
          let rooms = data.rooms || [];
          displayRooms(rooms);
        } else {
          displayRooms([]);
        }
      } catch (err) {
        console.error('[Betting] Load rooms error:', err);
        displayRooms([]);
      }
    }

    function displayRooms(rooms) {
      const roomsList = document.getElementById('roomsList');
      
      if (rooms.length === 0) {
        // Show test rooms in test mode
        if (TEST_MODE) {
          const testRooms = [
            {
              roomId: 'test_room_1',
              creator: '7xKXt...9mP2Q',
              betAmount: 10000,
              player2: null,
              timestamp: Date.now() - 30000,
              isTest: true
            },
            {
              roomId: 'test_room_2',
              creator: '5yLZu...3nR8T',
              betAmount: 50000,
              player2: null,
              timestamp: Date.now() - 60000,
              isTest: true
            }
          ];
          roomsList.innerHTML = testRooms.map(room => {
            const canJoin = walletConnected && playerBalance >= room.betAmount;
            const safeRoomId = escapeHtml(room.roomId);
            const safeBetAmount = escapeHtml(room.betAmount.toString());
            const safeCreator = escapeHtml(room.creator);
            return `
              <div class="room-card" style="opacity: 0.8; border-style: dashed;">
                <div class="room-header">
                  <div class="room-bet">üí∞ ${escapeHtml(formatNumber(room.betAmount))} Luna</div>
                  <div class="room-creator">${safeCreator}</div>
                </div>
                <div class="room-status">
                  üü° Waiting for opponent...
                </div>
                <button class="join-btn" onclick="joinTestRoom('${safeRoomId}', ${safeBetAmount}, '${safeCreator}')" style="background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.4));">
                  Join Room
                </button>
              </div>
            `;
          }).join('');
        } else {
          roomsList.innerHTML = '<div class="empty-rooms">No rooms available. Create one!</div>';
        }
        return;
      }
      
      roomsList.innerHTML = rooms.map(room => {
        const isMyRoom = room.creator === walletPublicKey;
        const canJoin = !isMyRoom && walletConnected && playerBalance >= room.betAmount;
        const isTest = room.roomId && room.roomId.startsWith('test_');
        
        // Sanitize all user inputs
        const safeRoomId = escapeHtml(room.roomId);
        const safeBetAmount = escapeHtml(room.betAmount.toString());
        const safeCreator = typeof room.creator === 'string' && room.creator.length > 16 
          ? escapeHtml(room.creator.substring(0, 8) + '...' + room.creator.substring(room.creator.length - 8))
          : escapeHtml(room.creator);
        const safeFee = escapeHtml(formatSol(calculateFee(room.betAmount)));
        
        return `
          <div class="room-card" ${isTest ? 'style="opacity: 0.8; border-style: dashed;"' : ''}>
            <div class="room-header">
              <div class="room-bet">üí∞ ${escapeHtml(formatNumber(room.betAmount))} Luna</div>
              <div class="room-creator">${safeCreator}</div>
            </div>
            <div class="room-status">
              ${room.player2 ? 'üü¢ Match in progress' : 'üü° Waiting for opponent...'}
            </div>
            <div style="font-size: 0.85em; color: #00ffff; opacity: 0.7; margin-top: 5px;">
              üí∞ Fee: ${safeFee} SOL (1% of bet)
            </div>
            ${!isMyRoom && !room.player2 ? `
              <button class="join-btn" ${canJoin || isTest ? '' : 'disabled'} onclick="${isTest ? `joinTestRoom('${safeRoomId}', ${safeBetAmount}, '${safeCreator}')` : `joinRoom('${safeRoomId}', ${safeBetAmount})`}">
                ${canJoin ? 'üéÆ Challenge!' : '‚ùå Insufficient balance'}
              </button>
            ` : ''}
            ${isMyRoom ? `
              <div style="color: #00ffff; margin-top: 10px; margin-bottom: 10px;">Your room - Waiting for challenger...</div>
              <button class="cancel-btn" onclick="cancelRoom('${safeRoomId}')" style="background: linear-gradient(135deg, rgba(255, 0, 0, 0.3), rgba(255, 100, 100, 0.3)); border: 2px solid #ff0000; color: #ff0000; padding: 10px 20px; border-radius: 8px; cursor: pointer; width: 100%; font-family: 'Courier New', monospace; transition: all 0.3s;">
                ‚ùå Cancel Room
              </button>
            ` : ''}
            ${room.player2 === walletPublicKey && !room.choices?.player1 && !room.choices?.player2 ? `
              <button class="cancel-btn" onclick="leaveRoom('${safeRoomId}')" style="background: linear-gradient(135deg, rgba(255, 0, 0, 0.3), rgba(255, 100, 100, 0.3)); border: 2px solid #ff0000; color: #ff0000; padding: 10px 20px; border-radius: 8px; cursor: pointer; width: 100%; margin-top: 10px; font-family: 'Courier New', monospace; transition: all 0.3s;">
                üö™ Leave Room
              </button>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    window.joinRoom = async function(roomId, betAmount) {
      if (!walletConnected || !walletPublicKey) {
        alert('Please connect your wallet first!');
        return;
      }
      
      if (playerBalance < betAmount) {
        alert(`Insufficient balance! You need ${formatNumber(betAmount)} Luna tokens.`);
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: walletPublicKey,
            roomId: roomId
          })
        });
        
        const data = await response.json();
        
        if (data.ok) {
          currentRoomId = roomId;
          opponentWallet = data.creator;
          const feeInSol = calculateFee(betAmount);
          alert(`Joined room! Game starting...\n\nFee collected: ${formatSol(feeInSol)} SOL (1% of ${formatSol(lunaToSol(betAmount))} SOL)`);
          
          
          startGame();
        } else {
          alert('Failed to join room: ' + (data.message || 'Unknown error'));
        }
      } catch (err) {
        console.error('[Betting] Join room error:', err);
        alert('Failed to join room: ' + err.message);
      }
    };

    // Join test room (simulate game flow)
    window.joinTestRoom = async function(roomId, betAmount, creatorName) {
      if (!walletConnected || !walletPublicKey) {
        // Auto-connect for test mode
        if (TEST_MODE) {
          walletPublicKey = 'TestWallet_' + Math.random().toString(36).substring(2, 15);
          walletConnected = true;
          playerBalance = 1000000;
          document.getElementById('connectWalletBtn').classList.add('hidden');
          document.getElementById('disconnectWalletBtn').classList.remove('hidden');
          document.getElementById('walletInfo').classList.remove('hidden');
          const sanitizedWallet = sanitizeWalletAddress(walletPublicKey);
          const shortWallet = sanitizedWallet.length > 16 
            ? `${sanitizedWallet.substring(0, 8)}...${sanitizedWallet.substring(sanitizedWallet.length - 8)}`
            : sanitizedWallet;
          document.getElementById('walletInfo').innerHTML = `
            <strong>Connected:</strong> ${escapeHtml(shortWallet)}<br>
            <strong>Balance:</strong> <span id="balanceDisplay">${escapeHtml(formatNumber(playerBalance))} Luna</span>
          `;
        } else {
          alert('Please connect your wallet first!');
          return;
        }
      }
      
      currentRoomId = roomId;
      opponentWallet = creatorName;
      
      alert('Joined room! Game starting...');
      startGame();
    };

    document.getElementById('createRoomBtn').addEventListener('click', async () => {
      const betAmount = parseInt(document.getElementById('betAmount').value);
      
      if (!betAmount || betAmount < 1) {
        alert('Please enter a valid bet amount (minimum 1 Luna)');
        return;
      }
      
      if (!walletConnected || !walletPublicKey) {
        alert('Please connect your wallet first!');
        return;
      }
      
      if (playerBalance < betAmount) {
        alert(`Insufficient balance! You have ${formatNumber(playerBalance)} Luna, but need ${formatNumber(betAmount)} Luna.`);
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/create`, addCSRFToken({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: walletPublicKey,
            betAmount: betAmount
          })
        }));
        
        const data = await response.json();
        
        if (data.ok) {
          currentRoomId = data.roomId;
          const feeInSol = calculateFee(betAmount);
          alert(`Room created! Waiting for challenger...\n\nFee collected: ${formatSol(feeInSol)} SOL (1% of ${formatSol(lunaToSol(betAmount))} SOL)`);
          document.getElementById('betAmount').value = '';
          document.getElementById('feeDisplay').style.display = 'none';
          await loadRooms();
          
        } else {
          alert('Failed to create room: ' + (data.message || 'Unknown error'));
        }
      } catch (err) {
        console.error('[Betting] Create room error:', err);
        alert('Failed to create room: ' + err.message);
      }
    });

    // Game Logic
    function startGame() {
      gameActive = true;
      document.getElementById('bettingSection').classList.add('hidden');
      document.getElementById('gameArea').classList.add('active');
      
      // Reset hands
      updateHand('playerHand', 'default');
      updateHand('opponentHand', 'default');
      
      // Start countdown
      startCountdown();
    }
    
    function startCountdown() {
      let countdown = 3;
      document.getElementById('status').textContent = `Game starting in ${countdown}...`;
      document.querySelectorAll('.choice-btn').forEach(btn => {
        btn.disabled = true;
      });
      
      // Play countdown sound immediately
      playCountdownSound();
      
      countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          document.getElementById('status').textContent = `Game starting in ${countdown}...`;
          // Play countdown sound for each number
          playCountdownSound();
        } else {
          clearInterval(countdownInterval);
          document.getElementById('status').textContent = 'Choose your hand!';
          // Enable choice buttons
          document.querySelectorAll('.choice-btn').forEach(btn => {
            btn.disabled = false;
            btn.addEventListener('click', handleChoice);
          });
        }
      }, 1000);
    }

    function showCountdown(callback) {
      // Create countdown overlay if it doesn't exist
      let overlay = document.getElementById('countdownOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'countdownOverlay';
        overlay.className = 'countdown-overlay';
        const countdownDiv = document.createElement('div');
        countdownDiv.className = 'countdown-number';
        countdownDiv.id = 'countdownNumber';
        countdownDiv.textContent = '3';
        overlay.innerHTML = '';
        overlay.appendChild(countdownDiv);
        document.body.appendChild(overlay);
      }
      
      overlay.style.display = 'flex';
      const countdownEl = document.getElementById('countdownNumber');
      let countdown = 3;
      
      countdownEl.textContent = countdown;
      
      // Play countdown sound immediately
      playCountdownSound();
      
      const countdownTimer = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          countdownEl.textContent = countdown;
          // Play countdown sound for each number
          playCountdownSound();
        } else {
          clearInterval(countdownTimer);
          overlay.style.display = 'none';
          if (callback) callback();
        }
      }, 1000);
    }
    
    function startHandCycle(handId, finalChoice, duration = 2000) {
      const choices = ['rock', 'paper', 'scissors'];
      let currentIndex = 0;
      const cycleSpeed = 150; // milliseconds per cycle
      const cycles = Math.floor(duration / cycleSpeed);
      let cycleCount = 0;
      
      handCycleInterval = setInterval(() => {
        updateHand(handId, choices[currentIndex]);
        currentIndex = (currentIndex + 1) % choices.length;
        cycleCount++;
        
        if (cycleCount >= cycles) {
          clearInterval(handCycleInterval);
          updateHand(handId, finalChoice);
        }
      }, cycleSpeed);
    }

    function updateHand(handId, choice) {
      const handEl = document.getElementById(handId);
      const img = document.createElement('img');
      img.src = HAND_IMAGES[choice] || HAND_IMAGES.default;
      img.alt = choice;
      handEl.innerHTML = '';
      handEl.appendChild(img);
    }

    async function handleChoice(event) {
      if (!gameActive || !currentRoomId) return;
      
      const choice = event.currentTarget.dataset.choice;
      
      // Disable buttons
      document.querySelectorAll('.choice-btn').forEach(btn => {
        btn.disabled = true;
      });
      
      updateHand('playerHand', choice);
      document.getElementById('status').textContent = 'Waiting for opponent...';
      
      // Show countdown before revealing result
      showCountdown(async () => {
        // Check if this is a test room
        const isTestRoom = currentRoomId && currentRoomId.startsWith('test_');
        
        if (isTestRoom) {
          // Simulate test room game flow
          // Simulate opponent choice (random)
          const opponentChoices = ['rock', 'paper', 'scissors'];
          const opponentChoice = opponentChoices[Math.floor(Math.random() * opponentChoices.length)];
          
          // Start hand cycling animation before revealing result
          document.getElementById('status').textContent = 'Revealing results...';
          startHandCycle('opponentHand', opponentChoice, 2000);
          
          // Determine winner
          let winner = null;
          if (choice === opponentChoice) {
            winner = 'draw';
          } else if (
            (choice === 'rock' && opponentChoice === 'scissors') ||
            (choice === 'paper' && opponentChoice === 'rock') ||
            (choice === 'scissors' && opponentChoice === 'paper')
          ) {
            winner = walletPublicKey; // Player wins
          } else {
            winner = opponentWallet; // Opponent wins
          }
          
          // Get bet amount from test room (extract from roomId or use default)
          let betAmount = 10000;
          if (currentRoomId.includes('test_room_1')) {
            betAmount = 10000;
          } else if (currentRoomId.includes('test_room_2')) {
            betAmount = 50000;
          } else if (currentRoomId.includes('test_room_3')) {
            betAmount = 100000;
          }
          
          // Show result after hand cycling animation
          setTimeout(() => {
            handleMatchResult({
              player1Choice: choice,
              player2Choice: opponentChoice,
              winner: winner,
              player1Wallet: walletPublicKey,
              player2Wallet: opponentWallet,
              betAmount: betAmount
            });
          }, 2000); // Wait for hand cycling to complete
        } else {
          // Real room - call API
      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/submit`, addCSRFToken({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: walletPublicKey,
            roomId: currentRoomId,
            choice: choice
          })
        }));
            
            const data = await response.json();
            
            if (!data.ok) {
              alert('Failed to submit choice: ' + (data.message || 'Unknown error'));
              document.querySelectorAll('.choice-btn').forEach(btn => {
                btn.disabled = false;
              });
            }
          } catch (err) {
            console.error('[Betting] Submit choice error:', err);
            alert('Failed to submit choice: ' + err.message);
            document.querySelectorAll('.choice-btn').forEach(btn => {
              btn.disabled = false;
            });
          }
        }
      });
    }

    window.cancelRoom = async function(roomId) {
      if (!walletConnected || !walletPublicKey) {
        alert('Please connect your wallet first!');
        return;
      }
      
      if (!confirm('Are you sure you want to cancel this room?')) {
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/cancel`, addCSRFToken({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: walletPublicKey,
            roomId: roomId
          })
        }));
        
        // Check if response is OK
        if (!response.ok) {
          const text = await response.text();
          console.error('[Betting] Cancel room error response:', text);
          try {
            const errorData = JSON.parse(text);
            alert('Failed to cancel room: ' + (errorData.message || errorData.error || 'Unknown error'));
          } catch (e) {
            alert('Failed to cancel room: Server returned error (Status ' + response.status + ')');
          }
          return;
        }
        
        // Check content type
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const text = await response.text();
          console.error('[Betting] Cancel room - non-JSON response:', text.substring(0, 100));
          alert('Failed to cancel room: Server returned invalid response');
          return;
        }
        
        const data = await response.json();
        
        if (data.ok) {
          alert('Room cancelled successfully!');
          currentRoomId = null;
          gameActive = false;
          // Reset UI
          document.getElementById('bettingSection').classList.remove('hidden');
          document.getElementById('gameArea').classList.remove('active');
          // Reload rooms
          await loadRooms();
        } else {
          alert('Failed to cancel room: ' + (data.message || 'Unknown error'));
        }
      } catch (err) {
        console.error('[Betting] Cancel room error:', err);
        alert('Failed to cancel room: ' + err.message);
      }
    };

    window.leaveRoom = async function(roomId) {
      if (!walletConnected || !walletPublicKey) {
        alert('Please connect your wallet first!');
        return;
      }
      
      if (!confirm('Are you sure you want to leave this room?')) {
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/cancel`, addCSRFToken({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: walletPublicKey,
            roomId: roomId
          })
        }));
        
        // Check if response is OK
        if (!response.ok) {
          const text = await response.text();
          console.error('[Betting] Leave room error response:', text);
          try {
            const errorData = JSON.parse(text);
            alert('Failed to leave room: ' + (errorData.message || errorData.error || 'Unknown error'));
          } catch (e) {
            alert('Failed to leave room: Server returned error (Status ' + response.status + ')');
          }
          return;
        }
        
        // Check content type
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const text = await response.text();
          console.error('[Betting] Leave room - non-JSON response:', text.substring(0, 100));
          alert('Failed to leave room: Server returned invalid response');
          return;
        }
        
        const data = await response.json();
        
        if (data.ok) {
          alert('Left room successfully!');
          currentRoomId = null;
          gameActive = false;
          // Reset UI
          document.getElementById('bettingSection').classList.remove('hidden');
          document.getElementById('gameArea').classList.remove('active');
          // Reload rooms
          await loadRooms();
        } else {
          alert('Failed to leave room: ' + (data.message || 'Unknown error'));
        }
      } catch (err) {
        console.error('[Betting] Leave room error:', err);
        alert('Failed to leave room: ' + err.message);
      }
    };

    function handleMatchResult(data) {
      gameActive = false;
      
      // Clear any intervals
      if (handCycleInterval) {
        clearInterval(handCycleInterval);
        handCycleInterval = null;
      }
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
      
      const { player1Choice, player2Choice, winner, player1Wallet, player2Wallet, betAmount } = data;
      
      // Update opponent hand (should already be set by hand cycling, but ensure it's correct)
      updateHand('opponentHand', player2Choice);
      
      let resultText = '';
      if (winner === 'draw') {
        resultText = 'ü§ù Draw! Bet returned.';
        playTieSound(); // Play tie sound
      } else if (winner === walletPublicKey) {
        resultText = `üéâ You Win! +${formatNumber(betAmount * 2)} Luna`;
        playWinSound(); // Play win sound (cheer)
      } else {
        resultText = `üò¢ You Lose! -${formatNumber(betAmount)} Luna`;
        playLoseSound(); // Play lose sound
      }
      
      document.getElementById('result').textContent = resultText;
      document.getElementById('status').textContent = '';
      
      // Reset after 5 seconds
      setTimeout(() => {
        resetGame();
      }, 5000);
    }

    function resetGame() {
      gameActive = false;
      currentRoomId = null;
      opponentWallet = null;
      
      // Clear any intervals
      if (handCycleInterval) {
        clearInterval(handCycleInterval);
        handCycleInterval = null;
      }
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
      
      document.getElementById('bettingSection').classList.remove('hidden');
      document.getElementById('gameArea').classList.remove('active');
      document.getElementById('result').textContent = '';
      document.getElementById('status').textContent = '';
      updateHand('playerHand', 'default');
      updateHand('opponentHand', 'default');
      loadRooms();
    }

    // Update fee display when bet amount changes
    window.updateFeeDisplay = async function() {
      const betAmount = parseInt(document.getElementById('betAmount').value) || 0;
      const feeDisplay = document.getElementById('feeDisplay');
      
      if (betAmount > 0) {
        const betValueInSol = lunaToSol(betAmount);
        
        // Get current betting fee percentage based on deposit status
        let feePercentage = 0.03; // Default 3%
        if (walletConnected && walletPublicKey) {
          try {
            const response = await fetch(`${API_BASE}/luna/deposit/status?wallet=${walletPublicKey}`);
            const data = await response.json();
            if (data.ok && data.hasDeposit) {
              feePercentage = data.deposit.feePercentage;
            }
          } catch (error) {
            console.error('[Fee] Error getting deposit status:', error);
            // Use default 3% on error
          }
        }
        
        const feeInSol = betValueInSol * feePercentage;
        
        document.getElementById('betValueInSol').textContent = formatSol(betValueInSol);
        document.getElementById('feeAmount').textContent = formatSol(feeInSol);
        const feePercentageDisplay = document.getElementById('feePercentageDisplay');
        if (feePercentageDisplay) {
          feePercentageDisplay.textContent = `${(feePercentage * 100).toFixed(0)}%`;
        }
        feeDisplay.style.display = 'block';
      } else {
        feeDisplay.style.display = 'none';
      }
    };

    // Competition Timer Functions
    async function updateCompetitionTimer() {
      try {
        const response = await fetch(`${API_BASE}/luna/rps/competition/time`);
        const data = await response.json();
        
        if (data.ok && data.isActive) {
          const { days, hours, minutes, seconds } = data.timeRemainingFormatted;
          
          const timerDays = document.getElementById('timerDays');
          const timerHours = document.getElementById('timerHours');
          const timerMinutes = document.getElementById('timerMinutes');
          const timerSeconds = document.getElementById('timerSeconds');
          
          if (timerDays) timerDays.textContent = days.toString().padStart(2, '0');
          if (timerHours) timerHours.textContent = hours.toString().padStart(2, '0');
          if (timerMinutes) timerMinutes.textContent = minutes.toString().padStart(2, '0');
          if (timerSeconds) timerSeconds.textContent = seconds.toString().padStart(2, '0');
        } else {
          // Competition ended
          const timerDays = document.getElementById('timerDays');
          const timerHours = document.getElementById('timerHours');
          const timerMinutes = document.getElementById('timerMinutes');
          const timerSeconds = document.getElementById('timerSeconds');
          
          if (timerDays) timerDays.textContent = '00';
          if (timerHours) timerHours.textContent = '00';
          if (timerMinutes) timerMinutes.textContent = '00';
          if (timerSeconds) timerSeconds.textContent = '00';
        }
      } catch (err) {
        console.error('[Betting] Competition timer error:', err);
      }
    }

    function startCompetitionTimer() {
      // Update immediately
      updateCompetitionTimer();
      
      // Update every second
      if (competitionTimerInterval) {
        clearInterval(competitionTimerInterval);
      }
      competitionTimerInterval = setInterval(updateCompetitionTimer, 1000);
    }

    function stopCompetitionTimer() {
      if (competitionTimerInterval) {
        clearInterval(competitionTimerInterval);
        competitionTimerInterval = null;
      }
    }

    // Neon Toggle System
    function initNeonToggle() {
      const neonToggle = document.getElementById('neonToggle');
      const body = document.body;
      
      // Load saved preference
      const neonEnabled = localStorage.getItem('neonEnabled') !== 'false';
      
      if (!neonEnabled) {
        body.classList.add('neon-off');
        neonToggle.textContent = 'üí° Neon: OFF';
      } else {
        body.classList.remove('neon-off');
        neonToggle.textContent = 'üí° Neon: ON';
      }
      
      neonToggle.addEventListener('click', () => {
        const isOff = body.classList.contains('neon-off');
        
        if (isOff) {
          body.classList.remove('neon-off');
          neonToggle.textContent = 'üí° Neon: ON';
          localStorage.setItem('neonEnabled', 'true');
        } else {
          body.classList.add('neon-off');
          neonToggle.textContent = 'üí° Neon: OFF';
          localStorage.setItem('neonEnabled', 'false');
        }
      });
    }

    // Sound Effects System for Navigation
    // Note: audioContext and playSound are already defined above, reuse them
    
    // Navigation click sound (short beep)
    function playNavClickSound() {
      playSound(600, 0.1, 'sine', 0.2);
    }

    // Add click sound to navigation links
    function initNavigationSounds() {
      const navLinks = document.querySelectorAll('#modeNavigation a');
      navLinks.forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          playNavClickSound();
          // Delay navigation to let sound play
          setTimeout(() => {
            window.location.href = link.href;
          }, 150);
        });
      });
    }


    // Total Fees Real-time Update
    let totalFeesUpdateInterval = null;
    
    async function updateTotalFees() {
      try {
        const response = await fetch(`${API_BASE}/luna/rps/betting/fees`);
        const data = await response.json();
        
        if (data.ok) {
          const totalFees = data.totalCollectedFees || 0;
          const transactionCount = Object.values(data.feeBreakdown || {}).reduce((sum, fee) => sum + (fee.transactionCount || 0), 0);
          const feeWallet = data.feeWallet || '--';
          
          // Update UI
          const totalFeesEl = document.getElementById('totalFeesAmount');
          const totalTransactionsEl = document.getElementById('totalFeesTransactions');
          const lastUpdateEl = document.getElementById('lastFeesUpdate');
          const feeWalletEl = document.getElementById('feeWalletAddress');
          
          if (totalFeesEl) {
            // formatSol returns "X.XXXX SOL", we only need the number part
            const formatted = formatSol(totalFees);
            totalFeesEl.textContent = formatted.replace(' SOL', '');
          }
          if (totalTransactionsEl) {
            totalTransactionsEl.textContent = transactionCount;
          }
          if (lastUpdateEl) {
            const now = new Date();
            lastUpdateEl.textContent = now.toLocaleTimeString();
          }
          if (feeWalletEl && feeWallet && feeWallet !== '--') {
            feeWalletEl.textContent = feeWallet.length > 16 
              ? `${feeWallet.substring(0, 8)}...${feeWallet.substring(feeWallet.length - 8)}`
              : feeWallet;
          }
        }
      } catch (error) {
        console.error('[Fees] Error updating total fees:', error);
      }
    }
    
    function startTotalFeesUpdates() {
      // Update immediately
      updateTotalFees();
      // Update every 5 seconds
      if (totalFeesUpdateInterval) {
        clearInterval(totalFeesUpdateInterval);
      }
      totalFeesUpdateInterval = setInterval(updateTotalFees, 5000);
    }
    
    function stopTotalFeesUpdates() {
      if (totalFeesUpdateInterval) {
        clearInterval(totalFeesUpdateInterval);
        totalFeesUpdateInterval = null;
      }
    }

    // Security: CSRF Token Management
    let csrfToken = null;
    
    async function fetchCSRFToken() {
      try {
        const response = await fetch(`${API_BASE}/api/csrf-token`);
        const data = await response.json();
        if (data.token) {
          csrfToken = data.token;
          console.log('[Security] CSRF token fetched');
        }
      } catch (err) {
        console.warn('[Security] Failed to fetch CSRF token:', err);
      }
    }
    
    // Refresh CSRF token every 30 minutes
    function startCSRFTokenRefresh() {
      fetchCSRFToken();
      setInterval(fetchCSRFToken, 30 * 60 * 1000);
    }
    
    // Helper function to add CSRF token to fetch requests
    function addCSRFToken(options = {}) {
      if (csrfToken && ['POST', 'PUT', 'DELETE'].includes((options.method || 'GET').toUpperCase())) {
        if (!options.headers) {
          options.headers = {};
        }
        options.headers['x-csrf-token'] = csrfToken;
      }
      return options;
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      initNeonToggle();
      initNavigationSounds();
      setupWalletConnection();
      connectWebSocket();
      // Fetch Luna price on page load
      await fetchLunaPrice();
      // Update price every minute
      setInterval(fetchLunaPrice, 60000);
      // Start competition timer
      startCompetitionTimer();
      // Start total fees updates
      startTotalFeesUpdates();
      // Start CSRF token management
      startCSRFTokenRefresh();
      
      // Setup deposit system on page load
      setupDepositSystem();
      
      // Check if wallet already connected OR has valid signature (like pump.fun)
      const storedSignature = localStorage.getItem('walletSignature');
      
      if (window.solana && window.solana.isPhantom) {
        // Case 1: Wallet is already connected
        if (window.solana.isConnected && window.solana.publicKey) {
          const currentWallet = window.solana.publicKey.toString();
          
          if (storedSignature) {
            try {
              const sigData = JSON.parse(storedSignature);
              
              // Verify signature is for current wallet
              if (sigData.publicKey === currentWallet) {
                console.log('[Betting] ‚úÖ Persistent connection found - using existing authenticated connection');
              } else {
                console.log('[Betting] Signature wallet mismatch - clearing signature');
                localStorage.removeItem('walletSignature');
              }
            } catch (err) {
              console.error('[Betting] Error checking signature:', err);
              localStorage.removeItem('walletSignature');
            }
          }
          
          walletPublicKey = currentWallet;
          walletConnected = true;
          await checkDepositStatus();
        }
        // Case 2: Wallet not connected but has valid signature - reconnect automatically (like pump.fun)
        else if (storedSignature && !window.solana.isConnected) {
          try {
            const sigData = JSON.parse(storedSignature);
            console.log('[Betting] ‚úÖ Valid signature found - reconnecting automatically (like pump.fun)...');
            
            // Try to reconnect silently first
            let response;
            try {
              response = await window.solana.connect({ onlyIfTrusted: true });
            } catch (silentErr) {
              // If silent connect fails, try normal connect (may show popup)
              console.log('[Betting] Silent connect failed, trying normal connect...');
              response = await window.solana.connect({ onlyIfTrusted: false });
            }
            
            if (response && response.publicKey) {
              const currentWallet = response.publicKey.toString();
              
              // Verify signature is for reconnected wallet
              if (sigData.publicKey === currentWallet) {
                console.log('[Betting] ‚úÖ Auto-reconnected with valid signature');
                walletPublicKey = currentWallet;
                walletConnected = true;
                
                // Update UI
                const connectBtn = document.getElementById('connectWalletBtn');
                const disconnectBtn = document.getElementById('disconnectWalletBtn');
                const walletInfo = document.getElementById('walletInfo');
                const connectBtnFixed = document.getElementById('connectWalletBtnFixed');
                const disconnectBtnFixed = document.getElementById('disconnectWalletBtnFixed');
                const walletInfoFixed = document.getElementById('walletInfoFixed');
                
                if (connectBtn) connectBtn.classList.add('hidden');
                if (disconnectBtn) disconnectBtn.classList.remove('hidden');
                if (walletInfo) {
                  walletInfo.textContent = `Wallet: ${walletPublicKey.substring(0, 8)}...${walletPublicKey.substring(walletPublicKey.length - 8)}`;
                  walletInfo.classList.remove('hidden');
                }
                if (connectBtnFixed) connectBtnFixed.classList.add('hidden');
                if (disconnectBtnFixed) {
                  disconnectBtnFixed.classList.remove('hidden');
                  disconnectBtnFixed.style.display = '';
                }
                if (walletInfoFixed) {
                  walletInfoFixed.innerHTML = `
                    <div><strong>Connected:</strong> ${walletPublicKey.substring(0, 8)}...${walletPublicKey.substring(walletPublicKey.length - 8)}</div>
                    <div><strong>Balance:</strong> <span id="balanceDisplayFixed">Checking...</span> Luna</div>
                  `;
                  walletInfoFixed.classList.remove('hidden');
                }
                
                await checkDepositStatus();
                await checkLunaBalance();
                startBalanceUpdate();
              } else {
                console.log('[Betting] Signature wallet mismatch after reconnect - clearing signature');
                localStorage.removeItem('walletSignature');
                // Still connect but without signature
                walletPublicKey = currentWallet;
                walletConnected = true;
                
                // Update UI
                const connectBtn = document.getElementById('connectWalletBtn');
                const disconnectBtn = document.getElementById('disconnectWalletBtn');
                const walletInfo = document.getElementById('walletInfo');
                const connectBtnFixed = document.getElementById('connectWalletBtnFixed');
                const disconnectBtnFixed = document.getElementById('disconnectWalletBtnFixed');
                const walletInfoFixed = document.getElementById('walletInfoFixed');
                
                if (connectBtn) connectBtn.classList.add('hidden');
                if (disconnectBtn) disconnectBtn.classList.remove('hidden');
                if (walletInfo) {
                  walletInfo.textContent = `Wallet: ${walletPublicKey.substring(0, 8)}...${walletPublicKey.substring(walletPublicKey.length - 8)}`;
                  walletInfo.classList.remove('hidden');
                }
                if (connectBtnFixed) connectBtnFixed.classList.add('hidden');
                if (disconnectBtnFixed) {
                  disconnectBtnFixed.classList.remove('hidden');
                  disconnectBtnFixed.style.display = '';
                }
                if (walletInfoFixed) {
                  walletInfoFixed.innerHTML = `
                    <div><strong>Connected:</strong> ${walletPublicKey.substring(0, 8)}...${walletPublicKey.substring(walletPublicKey.length - 8)}</div>
                    <div><strong>Balance:</strong> <span id="balanceDisplayFixed">Checking...</span> Luna</div>
                  `;
                  walletInfoFixed.classList.remove('hidden');
                }
                
                await checkDepositStatus();
                await checkLunaBalance();
                startBalanceUpdate();
              }
            }
          } catch (err) {
            console.warn('[Betting] Auto-reconnect failed:', err);
            // Don't clear signature - user might want to connect manually
          }
        }
      }
    });
    
    // Refresh rooms every 5 seconds
    roomsRefreshInterval = setInterval(loadRooms, 5000);
    
    // Load rooms on page load
    setTimeout(loadRooms, 1000);

    // Load contract address from backend
    async function loadContractAddress() {
      try {
        const response = await fetch(`${API_BASE}/luna/rps/contract-address`);
        const data = await response.json();
        
        if (data.ok && data.contractAddress) {
          const contractInput = document.getElementById('contractAddress');
          if (contractInput) {
            contractInput.value = data.contractAddress;
          }
          
          // Update buy DEX link from env
          const buyDexLink = document.getElementById('buyDexLink');
          if (buyDexLink && data.buyLink) {
            buyDexLink.href = data.buyLink;
          } else if (buyDexLink) {
            // Fallback to pump.fun if buyLink not provided
            buyDexLink.href = `https://pump.fun/${data.contractAddress}`;
          }
          
          // Update X/Twitter community link from env
          const communityLink = document.getElementById('communityLink');
          if (communityLink && data.xLink) {
            communityLink.href = data.xLink;
          }
        }
      } catch (error) {
        console.error('Failed to load contract address:', error);
        const contractInput = document.getElementById('contractAddress');
        if (contractInput) {
          contractInput.value = 'Error loading address';
        }
      }
    }

    // Copy contract address to clipboard
    function copyContractAddress() {
      const contractInput = document.getElementById('contractAddress');
      if (contractInput) {
        contractInput.select();
        contractInput.setSelectionRange(0, 99999);
        document.execCommand('copy');
        
        const btn = event.target.closest('.contract-btn-copy');
        if (btn) {
          const originalText = btn.innerHTML;
          btn.innerHTML = '<span>‚úì</span> Copied!';
          setTimeout(() => {
            btn.innerHTML = originalText;
          }, 2000);
        }
      }
    }

    // View contract address on Solscan
    function viewContractAddress() {
      const contractInput = document.getElementById('contractAddress');
      if (contractInput && contractInput.value && contractInput.value !== 'Loading...' && contractInput.value !== 'Error loading address') {
        window.open(`https://solscan.io/token/${contractInput.value}`, '_blank');
      }
    }

    // Open buy DEX link
    function openBuyDex(event) {
      event.preventDefault();
      const buyDexLink = document.getElementById('buyDexLink');
      if (buyDexLink && buyDexLink.href && buyDexLink.href !== '#') {
        window.open(buyDexLink.href, '_blank');
      } else {
        alert('Contract address not loaded yet. Please wait a moment and try again.');
      }
    }

    // Open community link (X/Twitter)
    function openCommunity(event) {
      event.preventDefault();
      const communityLink = document.getElementById('communityLink');
      if (communityLink && communityLink.href && communityLink.href !== '#') {
        window.open(communityLink.href, '_blank');
      } else {
        alert('Community link not loaded yet. Please wait a moment and try again.');
      }
    }

  </script>
  <script>
    // Initialize UI components when wallet connects
    function initializeUIComponents() {
      if (walletPublicKey) {
        // Initialize Notification System
        if (typeof notificationManager !== 'undefined') {
          notificationManager.init(walletPublicKey);
        }
        
      }
    }
    
    // Call when wallet connects
    const originalConnectWallet = window.connectWallet;
    window.connectWallet = async function() {
      const result = await originalConnectWallet();
      if (walletPublicKey) {
        initializeUIComponents();
      }
      return result;
    };
    
    // Disable Notifications and Chat +
    if (typeof notificationManager !== 'undefined') {
      notificationManager.createUI = function() {}; // Disable notifications
    }
    if (typeof chatManager !== 'undefined') {
      chatManager.createUI = function() {}; // Disable chat +
    }
    
    // Remove any existing notification/chat elements
    document.addEventListener('DOMContentLoaded', () => {
      const notificationBtn = document.getElementById('notification-btn');
      const notificationPanel = document.getElementById('notification-panel');
      const chatContainer = document.getElementById('chat-container');
      if (notificationBtn) notificationBtn.remove();
      if (notificationPanel) notificationPanel.remove();
      if (chatContainer) chatContainer.remove();
    });
    
    // Disable initializeRoomChat function
    window.initializeRoomChat = function(roomId) {
      // Disabled
    };
  </script>
</body>
</html>

